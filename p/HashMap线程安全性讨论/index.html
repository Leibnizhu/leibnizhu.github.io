<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="HashMap线程安全性讨论 去年写的 HashMap源码阅读笔记 分析了JDK8 中的HashMap源码的get()和put()两大方法，当时并没"><title>HashMap线程安全性讨论</title>
<link rel=canonical href=https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/><link rel=stylesheet href=/scss/style.min.23e1d8e9a6160c668989a401c0af6c7e300683648c9edcf1dec562b9b0efc7b4.css><meta property="og:title" content="HashMap线程安全性讨论"><meta property="og:description" content="HashMap线程安全性讨论 去年写的 HashMap源码阅读笔记 分析了JDK8 中的HashMap源码的get()和put()两大方法，当时并没"><meta property="og:url" content="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/"><meta property="og:site_name" content="Heaven's Door"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="HashMap"><meta property="article:tag" content="源码阅读笔记"><meta property="article:tag" content="线程安全"><meta property="article:published_time" content="2017-08-01T16:36:39+08:00"><meta property="article:modified_time" content="2017-08-01T16:36:39+08:00"><meta property="og:image" content="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/sundown.png"><meta name=twitter:title content="HashMap线程安全性讨论"><meta name=twitter:description content="HashMap线程安全性讨论 去年写的 HashMap源码阅读笔记 分析了JDK8 中的HashMap源码的get()和put()两大方法，当时并没"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/sundown.png"><link rel="shortcut icon" href=favicon.jpg><script async src="https://www.googletagmanager.com/gtag/js?id=G-TK434TCNDK"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TK434TCNDK",{anonymize_ip:!1})}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu4af873b90feb2f44d14cf5fcf42d034c_7593_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Heaven's Door</a></h1><h2 class=site-description>That cold black cloud is comin' down, Feels like I'm knockin' on heaven's door…</h2></div></header><ol class=social-menu><li><a href=/ title=Home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg></a></li><li><a href=https://github.com/leibnizhu target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:leibnizhu@gmail.com target=_blank title=Email><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-gmail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/About/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/Workouts/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-run" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="13" cy="4" r="1"/><path d="M4 17l5 1 .75-1.5"/><path d="M15 21v-4l-4-3 1-6"/><path d="M7 12V9l5-1 3 3 3 1"/></svg><span>Workouts</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li><a href=/Links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>Links</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/><img src=/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/sundown_hu870a7df00d029233d76d0371e0b6a9e2_43340_800x0_resize_box_3.png srcset="/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/sundown_hu870a7df00d029233d76d0371e0b6a9e2_43340_800x0_resize_box_3.png 800w, /p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/sundown_hu870a7df00d029233d76d0371e0b6a9e2_43340_1600x0_resize_box_3.png 1600w" width=800 height=267 loading=lazy alt="Featured image of post HashMap线程安全性讨论"></a></div><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/>HashMap线程安全性讨论</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Aug 01, 2017</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>7 minute read
</time><time class=article-time--reading>3316 words</time></div></footer></div></header><section class=article-content><h1 id=hashmap线程安全性讨论>HashMap线程安全性讨论</h1><p>去年写的 <a class=link href=/2016/12/24/HashMap%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0/>HashMap源码阅读笔记</a> 分析了JDK8 中的<code>HashMap</code>源码的<code>get()</code>和<code>put()</code>两大方法，当时并没有考虑到<code>HashMap</code>的线程安全性。<br>众所周知，<code>HashMap</code>并非线程安全的，但在 <em>JDK8</em> 之前，<code>HashMap</code>的线程安全不但体现在多线程读写可能出现数据错误，还存在一个多线程扩容导致的死循环Bug。本文将讨论这一Bug，及在 <em>JDK8</em> 中的修复，以及相关的<code>ConcurrentHashMap</code>。</p><h2 id=jdk8-之前的多线程扩容bug><em>JDK8</em> 之前的多线程扩容Bug</h2><h3 id=扩容代码解析>扩容代码解析</h3><p>我们直接看JDK7 中<code>HashMap</code>的扩容方法：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#fec418>void</span> <span style=color:#06b6ef>resize</span>(<span style=color:#fec418>int</span> newCapacity) {
</span></span><span style=display:flex><span>    Entry<span style=color:#5bc4bf>[]</span> oldTable <span style=color:#5bc4bf>=</span> table;
</span></span><span style=display:flex><span>    <span style=color:#fec418>int</span> oldCapacity <span style=color:#5bc4bf>=</span> oldTable.<span style=color:#06b6ef>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#776e71>//最大长度限制在Integer.MAX_VALUE</span>
</span></span><span style=display:flex><span>    <span style=color:#815ba4>if</span> (oldCapacity <span style=color:#5bc4bf>==</span> MAXIMUM_CAPACITY) {
</span></span><span style=display:flex><span>        threshold <span style=color:#5bc4bf>=</span> Integer.<span style=color:#06b6ef>MAX_VALUE</span>;
</span></span><span style=display:flex><span>        <span style=color:#815ba4>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Entry<span style=color:#5bc4bf>[]</span> newTable <span style=color:#5bc4bf>=</span> <span style=color:#815ba4>new</span> Entry<span style=color:#5bc4bf>[</span>newCapacity<span style=color:#5bc4bf>]</span>;<span style=color:#776e71>//按新的长度分配哈希表数组</span>
</span></span><span style=display:flex><span>    transfer(newTable);<span style=color:#776e71>//将旧的哈希表重新分配到新哈希表里，可能导致环链</span>
</span></span><span style=display:flex><span>    table <span style=color:#5bc4bf>=</span> newTable;<span style=color:#776e71>//将新的哈希表复制到HashMap的table变量</span>
</span></span><span style=display:flex><span>    threshold <span style=color:#5bc4bf>=</span> (<span style=color:#fec418>int</span>)(newCapacity <span style=color:#5bc4bf>*</span> loadFactor);<span style=color:#776e71>//按新容量更新扩容阈值</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fec418>void</span> <span style=color:#06b6ef>transfer</span>(Entry<span style=color:#5bc4bf>[]</span> newTable) {
</span></span><span style=display:flex><span>    Entry<span style=color:#5bc4bf>[]</span> src <span style=color:#5bc4bf>=</span> table;
</span></span><span style=display:flex><span>    <span style=color:#fec418>int</span> newCapacity <span style=color:#5bc4bf>=</span> newTable.<span style=color:#06b6ef>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#815ba4>for</span> (<span style=color:#fec418>int</span> j <span style=color:#5bc4bf>=</span> 0; j <span style=color:#5bc4bf>&lt;</span> src.<span style=color:#06b6ef>length</span>; j<span style=color:#5bc4bf>++</span>) {
</span></span><span style=display:flex><span>        Entry<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> e <span style=color:#5bc4bf>=</span> src<span style=color:#5bc4bf>[</span>j<span style=color:#5bc4bf>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#815ba4>if</span> (e <span style=color:#5bc4bf>!=</span> <span style=color:#815ba4>null</span>) {
</span></span><span style=display:flex><span>            src<span style=color:#5bc4bf>[</span>j<span style=color:#5bc4bf>]</span> <span style=color:#5bc4bf>=</span> <span style=color:#815ba4>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#776e71>//关键部分</span>
</span></span><span style=display:flex><span>            <span style=color:#815ba4>do</span> {
</span></span><span style=display:flex><span>                Entry<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> next <span style=color:#5bc4bf>=</span> e.<span style=color:#06b6ef>next</span>;<span style=color:#776e71>//获得原来链表中的下一个元素</span>
</span></span><span style=display:flex><span>                <span style=color:#fec418>int</span> i <span style=color:#5bc4bf>=</span> indexFor(e.<span style=color:#06b6ef>hash</span>, newCapacity);<span style=color:#776e71>//获取扩容后新的下标，可能跟原来一样，或者比原来的大newCapacity/2</span>
</span></span><span style=display:flex><span>                e.<span style=color:#06b6ef>next</span> <span style=color:#5bc4bf>=</span> newTable<span style=color:#5bc4bf>[</span>i<span style=color:#5bc4bf>]</span>;<span style=color:#776e71>//设置当前元素在链表的下一个元素为新哈希表对应位置原来的元素，也就是说旧元素会被往后推，该链表上最早读取的元素会成为尾部</span>
</span></span><span style=display:flex><span>                newTable<span style=color:#5bc4bf>[</span>i<span style=color:#5bc4bf>]</span> <span style=color:#5bc4bf>=</span> e;<span style=color:#776e71>//哈希表的入口改为当前元素</span>
</span></span><span style=display:flex><span>                e <span style=color:#5bc4bf>=</span> next;<span style=color:#776e71>//遍历原来链表的下一个元素</span>
</span></span><span style=display:flex><span>            } <span style=color:#815ba4>while</span> (e <span style=color:#5bc4bf>!=</span> <span style=color:#815ba4>null</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>工作原理在上面代码的注释里说得比较清楚了，值得注意的是，<code>transfer(newTable)</code>之后的新哈希表里，每个链表的顺序都与扩容之前的刚好相反，这一点直接注定了会出现多线程扩容Bug。</p><h3 id=扩容时的多线程死循环bug>扩容时的多线程死循环Bug</h3><p>如上面的分析，由于扩容后每个链表的顺序都调转了，因此定性地分析，多线程同时触发扩容的时候，有可能其中一个线程已经把链表调转了，而另一个线程获取了链表调转前的状态，重新获取到时间片的时候，再次翻转，导致next引用的赋值出错，链表中构成环；这样在调用<code>get()</code>方法的时候，进入到这个链表就会陷入死循环。
具体的举例分析，可以参考美团点评技术团队的文章 <a class=link href=https://tech.meituan.com/java-hashmap.html target=_blank rel=noopener>Java 8系列之重新认识HashMap</a> ，在此贴出关键的部分：</p><blockquote><p>代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#815ba4>public</span> <span style=color:#815ba4>class</span> <span style=color:#fec418>HashMapInfiniteLoop</span> {
</span></span><span style=display:flex><span>    <span style=color:#815ba4>private</span> <span style=color:#815ba4>static</span> HashMap<span style=color:#5bc4bf>&lt;</span>Integer,String<span style=color:#5bc4bf>&gt;</span> map <span style=color:#5bc4bf>=</span> <span style=color:#815ba4>new</span> HashMap<span style=color:#5bc4bf>&lt;</span>Integer,String<span style=color:#5bc4bf>&gt;</span>(2<span style=color:#ef6155>，</span>0.<span style=color:#06b6ef>75f</span>);
</span></span><span style=display:flex><span>    <span style=color:#815ba4>public</span> <span style=color:#815ba4>static</span> <span style=color:#fec418>void</span> <span style=color:#06b6ef>main</span>(String<span style=color:#5bc4bf>[]</span> args) {
</span></span><span style=display:flex><span>        map.<span style=color:#06b6ef>put</span>(5<span style=color:#ef6155>，</span> <span style=color:#48b685>&#34;C&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#815ba4>new</span> Thread(<span style=color:#48b685>&#34;Thread1&#34;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#815ba4>public</span> <span style=color:#fec418>void</span> <span style=color:#06b6ef>run</span>() {
</span></span><span style=display:flex><span>                map.<span style=color:#06b6ef>put</span>(7, <span style=color:#48b685>&#34;B&#34;</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#06b6ef>out</span>.<span style=color:#06b6ef>println</span>(map);
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>        }.<span style=color:#06b6ef>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#815ba4>new</span> Thread(<span style=color:#48b685>&#34;Thread2&#34;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#815ba4>public</span> <span style=color:#fec418>void</span> <span style=color:#06b6ef>run</span>() {
</span></span><span style=display:flex><span>                map.<span style=color:#06b6ef>put</span>(3, <span style=color:#48b685>&#34;A&#34;</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#06b6ef>out</span>.<span style=color:#06b6ef>println</span>(map);
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>        }.<span style=color:#06b6ef>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。<br><img src=/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3.png width=1388 height=628 srcset="/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3_hu8c609b8e724bfb2c0290ec31e1a358b7_20420_480x0_resize_box_3.png 480w, /p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3_hu8c609b8e724bfb2c0290ec31e1a358b7_20420_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=221 data-flex-basis=530px>
注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。<br><img src=/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4.png width=1380 height=522 srcset="/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4_hu4e735beccad0b142c011203082f64e5a_15190_480x0_resize_box_3.png 480w, /p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4_hu4e735beccad0b142c011203082f64e5a_15190_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=264 data-flex-basis=634px><br><img src=/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5.png width=1374 height=484 srcset="/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5_hu2621d6ffff8728bce2c216db713e4324_15188_480x0_resize_box_3.png 480w, /p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5_hu2621d6ffff8728bce2c216db713e4324_15188_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=283 data-flex-basis=681px><br>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。<br><img src=/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6.png width=1384 height=482 srcset="/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6_hufeb79b1a930dbfa7f169a79531429de5_14874_480x0_resize_box_3.png 480w, /p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6_hufeb79b1a930dbfa7f169a79531429de5_14874_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=287 data-flex-basis=689px><br>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p></blockquote><h2 id=jdk8-如何修复多线程扩容bug><em>JDK8</em> 如何修复多线程扩容Bug</h2><p>正如我在 <a class=link href=/2016/12/24/HashMap%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0/>HashMap源码阅读笔记</a> 中分析到的，<em>JDK8</em> 中<code>Node&lt;K,V>[] resize()</code>扩容方法利用了哈希表长度为2的幂，以及<code>get()</code>方法对哈希值取低位的特性，结合每次扩容哈希表大小都增倍等特性，每次扩容，一个哈希桶里的元素在扩容后的位置，只会是原位置，或者原位置+原哈希表大小。<br>因此扩容的时候可以将一个哈希桶的扩容结果分为两个链表，还在原来位置的记为 <em>低位链表</em>(我自己起的名字)，用<code>loHead loTail</code>标记其头尾；扩容后分配到原位置+原哈希表大小的构成 <em>高位链表</em>(同样是我自己起的名字)，用<code>hiHead hiTail</code>标记其头尾。<br>具体实现的核心部分代码如下（省略了特殊容量处理、红黑树处理等等代码）：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#815ba4>final</span> Node<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;[]</span> <span style=color:#06b6ef>resize</span>() {
</span></span><span style=display:flex><span>    <span style=color:#776e71>/*…………省略前面代码…………*/</span>
</span></span><span style=display:flex><span>    Node<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span>loHead<span style=color:#5bc4bf>=</span><span style=color:#815ba4>null</span>,loTail<span style=color:#5bc4bf>=</span><span style=color:#815ba4>null</span>;<span style=color:#776e71>//记录低位链表头尾位置</span>
</span></span><span style=display:flex><span>    Node<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span>hiHead<span style=color:#5bc4bf>=</span><span style=color:#815ba4>null</span>,hiTail<span style=color:#5bc4bf>=</span><span style=color:#815ba4>null</span>;<span style=color:#776e71>//记录高位链表头尾位置</span>
</span></span><span style=display:flex><span>    Node<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span>next;<span style=color:#776e71>//记录当前链表元素在原来链表中的下一个元素，便于下次循环使用</span>
</span></span><span style=display:flex><span>    <span style=color:#776e71>//遍历哈希桶的链表，拆分成高位和低位链表</span>
</span></span><span style=display:flex><span>    <span style=color:#815ba4>do</span>{
</span></span><span style=display:flex><span>        next<span style=color:#5bc4bf>=</span>e.<span style=color:#06b6ef>next</span>;
</span></span><span style=display:flex><span>        <span style=color:#815ba4>if</span>((e.<span style=color:#06b6ef>hash</span><span style=color:#5bc4bf>&amp;</span>oldCap)<span style=color:#5bc4bf>==</span>0){ <span style=color:#776e71>//新增的有效哈希位为0，即当前元素扩容后分配到 低位链表</span>
</span></span><span style=display:flex><span>            <span style=color:#815ba4>if</span>(loTail<span style=color:#5bc4bf>==</span><span style=color:#815ba4>null</span>) <span style=color:#776e71>//低位链表尚未初始化</span>
</span></span><span style=display:flex><span>                loHead<span style=color:#5bc4bf>=</span>e; <span style=color:#776e71>//设置低位链表头部</span>
</span></span><span style=display:flex><span>            <span style=color:#815ba4>else</span>
</span></span><span style=display:flex><span>                loTail.<span style=color:#06b6ef>next</span><span style=color:#5bc4bf>=</span>e; <span style=color:#776e71>//低位链表尾部增加当前元素，以保持原链表顺序</span>
</span></span><span style=display:flex><span>            loTail<span style=color:#5bc4bf>=</span>e; <span style=color:#776e71>//更新低位链表的尾部</span>
</span></span><span style=display:flex><span>        }<span style=color:#815ba4>else</span>{ <span style=color:#776e71>//新增的有效哈希位为1，即当前元素扩容后分配到 高位链表</span>
</span></span><span style=display:flex><span>            <span style=color:#815ba4>if</span>(hiTail<span style=color:#5bc4bf>==</span><span style=color:#815ba4>null</span>) <span style=color:#776e71>//高低位链表尚未初始化</span>
</span></span><span style=display:flex><span>                hiHead<span style=color:#5bc4bf>=</span>e; <span style=color:#776e71>//设置高位链表头部</span>
</span></span><span style=display:flex><span>            <span style=color:#815ba4>else</span>
</span></span><span style=display:flex><span>                hiTail.<span style=color:#06b6ef>next</span><span style=color:#5bc4bf>=</span>e; <span style=color:#776e71>//高位链表尾部增加当前元素，以保持原链表顺序</span>
</span></span><span style=display:flex><span>            hiTail<span style=color:#5bc4bf>=</span>e; <span style=color:#776e71>//更新高位链表的尾部</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }<span style=color:#815ba4>while</span>((e<span style=color:#5bc4bf>=</span>next)<span style=color:#5bc4bf>!=</span><span style=color:#815ba4>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#776e71>//更新两个链表到哈希表中</span>
</span></span><span style=display:flex><span>    <span style=color:#815ba4>if</span>(loTail<span style=color:#5bc4bf>!=</span><span style=color:#815ba4>null</span>){ <span style=color:#776e71>//扩容后低位链表不为空，需要处理</span>
</span></span><span style=display:flex><span>        loTail.<span style=color:#06b6ef>next</span><span style=color:#5bc4bf>=</span><span style=color:#815ba4>null</span>; <span style=color:#776e71>//低位链表设置尾部结束</span>
</span></span><span style=display:flex><span>        newTab<span style=color:#5bc4bf>[</span>j<span style=color:#5bc4bf>]=</span>loHead; <span style=color:#776e71>//哈希桶设置链表入口</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#815ba4>if</span>(hiTail<span style=color:#5bc4bf>!=</span><span style=color:#815ba4>null</span>){ <span style=color:#776e71>//扩容后高位链表不为空，需要处理</span>
</span></span><span style=display:flex><span>        hiTail.<span style=color:#06b6ef>next</span><span style=color:#5bc4bf>=</span><span style=color:#815ba4>null</span>; <span style=color:#776e71>//高位链表设置尾部结束</span>
</span></span><span style=display:flex><span>        newTab<span style=color:#5bc4bf>[</span>j<span style=color:#5bc4bf>+</span>oldCap<span style=color:#5bc4bf>]=</span>hiHead; <span style=color:#776e71>//哈希桶设置链表入口</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#776e71>/*…………省略后面代码…………*/</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>具体处理的过程我在上面的注释里说得比较清楚了，包括代码之前的那段文字。<br>可以看到，扩容后，原来哈希桶的链表被拆分为两个，两个链表中的元素都能继续维持原有的顺序。这样就算在多线程环境下同时扩容，一个线程A读取链表状态后停止工作，另一个线程B对同一链表的前几个元素进行扩容分成两个链表，此时线程A恢复工作，由于线程B对链表元素的顺序没有发生变化，所以线程A恢复工作后只是重复了拆分链表的工作，而不会因为链表已被改变顺序而导致环的生成，因此不会发生死循环的问题。<br>也就是说 <em>JDK8</em> 的<code>HashMap</code>扩容方法不但效率提升了（根据哈希值特点拆分链表，红黑树），而且还维持了扩容前后的链表顺序，从而解决了多线程扩容使链表产生环，导致死循环的问题。</p><h2 id=其他线程安全map>其他线程安全Map</h2><h3 id=hashtable类>Hashtable类</h3><p>类名叫<code>Hashtable</code>不叫<code>HashTable</code>真是逼死强迫症。这个类现在很少用了，从源码可以看到，它是在<code>get() put()</code>等方法的声明里加了<code>synchronized</code>关键字来实现多线程安全的，因此显然效率比较低。</p><h3 id=collectionssynchronizedmap方法>Collections.synchronizedMap()方法</h3><p>在<code>Collections</code>工具类里有</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#815ba4>public</span> <span style=color:#815ba4>static</span> <span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> Map<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> <span style=color:#06b6ef>synchronizedMap</span>(Map<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> m);
</span></span></code></pre></div><p>方法，传入将普通的Map实例，返回一个线程安全的Map实例。实现方法也比较简单，返回的是<code>Collections</code>的内部类：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#815ba4>private</span> <span style=color:#815ba4>static</span> <span style=color:#815ba4>class</span> <span style=color:#fec418>SynchronizedMap</span><span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> <span style=color:#815ba4>implements</span> Map<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span>, Serializable {
</span></span><span style=display:flex><span>    <span style=color:#815ba4>private</span> <span style=color:#815ba4>final</span> Map<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> m;     <span style=color:#776e71>// Backing Map</span>
</span></span><span style=display:flex><span>    <span style=color:#815ba4>final</span> Object      mutex;        <span style=color:#776e71>// Object on which to synchronize</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SynchronizedMap(Map<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> m) {
</span></span><span style=display:flex><span>        <span style=color:#815ba4>this</span>.<span style=color:#06b6ef>m</span> <span style=color:#5bc4bf>=</span> Objects.<span style=color:#06b6ef>requireNonNull</span>(m);
</span></span><span style=display:flex><span>        mutex <span style=color:#5bc4bf>=</span> <span style=color:#815ba4>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SynchronizedMap(Map<span style=color:#5bc4bf>&lt;</span>K,V<span style=color:#5bc4bf>&gt;</span> m, Object mutex) {
</span></span><span style=display:flex><span>        <span style=color:#815ba4>this</span>.<span style=color:#06b6ef>m</span> <span style=color:#5bc4bf>=</span> m;
</span></span><span style=display:flex><span>        <span style=color:#815ba4>this</span>.<span style=color:#06b6ef>mutex</span> <span style=color:#5bc4bf>=</span> mutex;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#815ba4>public</span> V <span style=color:#06b6ef>get</span>(Object key) {
</span></span><span style=display:flex><span>        <span style=color:#815ba4>synchronized</span> (mutex) {<span style=color:#815ba4>return</span> m.<span style=color:#06b6ef>get</span>(key);}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#815ba4>public</span> V <span style=color:#06b6ef>put</span>(K key, V value) {
</span></span><span style=display:flex><span>        <span style=color:#815ba4>synchronized</span> (mutex) {<span style=color:#815ba4>return</span> m.<span style=color:#06b6ef>put</span>(key, value);}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#776e71>/*………省略其他方法，大同小异………*/</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>的实例。上面也给出了简要的类代码，实现的方法相当简单粗暴，由构造方法传入线程不安全的类实例，用一个锁（默认是自身，也可以在构造方法里传入），在各种<code>Map</code>接口的方法里面使用这个锁对线程不安全的类实例方法进行同步，也就是一个包装的设计模式，用同步代码块包装原有方法。<br>显然这样得到的线程安全类的效率也不高。</p><h3 id=concurrenthashmap类>ConcurrentHashMap类</h3><p><em>JDK8</em> 之前的<code>ConcurrentHashMap</code>使用Segment（锁段）提高同步的效率，而 <em>JDK8</em> 开始利用CAS算法大大提高了实现线程安全的效率。有空要再写一篇博客分析一下<code>ConcurrentHashMap</code>的源码。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/HashMap/>HashMap</a>
<a href=/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/>源码阅读笔记</a>
<a href=/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/>线程安全</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under Apache License 2.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/><div class=article-details><h2 class=article-title>HashMap源码阅读笔记</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//leibnizhu.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2016 -
2023 Heaven's Door</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.13.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#jdk8-之前的多线程扩容bug><em>JDK8</em> 之前的多线程扩容Bug</a><ol><li><a href=#扩容代码解析>扩容代码解析</a></li><li><a href=#扩容时的多线程死循环bug>扩容时的多线程死循环Bug</a></li></ol></li><li><a href=#jdk8-如何修复多线程扩容bug><em>JDK8</em> 如何修复多线程扩容Bug</a></li><li><a href=#其他线程安全map>其他线程安全Map</a><ol><li><a href=#hashtable类>Hashtable类</a></li><li><a href=#collectionssynchronizedmap方法>Collections.synchronizedMap()方法</a></li><li><a href=#concurrenthashmap类>ConcurrentHashMap类</a></li></ol></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>