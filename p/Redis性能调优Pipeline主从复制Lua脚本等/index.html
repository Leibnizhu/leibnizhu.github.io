<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这篇也是组内分享的文档，整理了之前两篇Netty+Redis的文章，加入了一些Redis调优相关的命令和内容。
Redis性能瓶颈 TCP连接 Redis协议基于TCP/IP协议，受限于TCP连接建立的速度（三次握手等），及网络中数据传输的速度。
数据包大小 Redis官方的一项测试显示，对于1k~10k以下的数据，Redis的吞吐量变化并不明显，吞吐量曲线在1k~10k左右出现拐点，如下图。
单线程 Redis服务器为C语言编写，使用异步非阻塞IO，目前坚持使用单线程（可能出于线程锁的效率考虑）。对于高并发访问+多核CPU场景而言，并不能充分使用CPU资源，可能发生某核心占用率很高，其他核心空闲，但Redis请求阻塞在队列中的情况。
搭建Redis集群可以解决该问题，但集群节点间访问引起的网络IO延时又带来新的问题。
Redis性能监控/测试 info命令 redis-cli中输入info可以显示当前Redis服务器的全部状态信息。这些信息按照内容被分成了很多部分，可以用额外的参数来单独获取，如下：
   参数名 说明     server 获取 server 信息，包括 version, OS, port 等信息   clients 获取 clients 信息，如客户端连接数等   memory 获取 server 的内存信息，包括当前内存消耗、内存使用峰值   persistence 获取 server 的持久化配置信息   stats 获取 server 的一些基本统计信息，如处理过的连接数量等   replication 获取 server 的主从配置信息   cpu 获取 server 的 CPU 使用信息   keyspace 获取 server 中各个 DB 的 key 的数量   cluster 获取集群节点信息，仅在开启集群后可见   commandstats 获取每种命令的统计信息，非常有用    slowlog命令 redis."><title>Redis性能调优——Pipeline、主从复制、Lua脚本等</title><link rel=canonical href=https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/><link rel=stylesheet href=/scss/style.min.f6e1f9fc3ff66a58601c08d5ce96493eafb5f1b936be2f7b2eacd3e7784f2f38.css><meta property="og:title" content="Redis性能调优——Pipeline、主从复制、Lua脚本等"><meta property="og:description" content="这篇也是组内分享的文档，整理了之前两篇Netty+Redis的文章，加入了一些Redis调优相关的命令和内容。
Redis性能瓶颈 TCP连接 Redis协议基于TCP/IP协议，受限于TCP连接建立的速度（三次握手等），及网络中数据传输的速度。
数据包大小 Redis官方的一项测试显示，对于1k~10k以下的数据，Redis的吞吐量变化并不明显，吞吐量曲线在1k~10k左右出现拐点，如下图。
单线程 Redis服务器为C语言编写，使用异步非阻塞IO，目前坚持使用单线程（可能出于线程锁的效率考虑）。对于高并发访问+多核CPU场景而言，并不能充分使用CPU资源，可能发生某核心占用率很高，其他核心空闲，但Redis请求阻塞在队列中的情况。
搭建Redis集群可以解决该问题，但集群节点间访问引起的网络IO延时又带来新的问题。
Redis性能监控/测试 info命令 redis-cli中输入info可以显示当前Redis服务器的全部状态信息。这些信息按照内容被分成了很多部分，可以用额外的参数来单独获取，如下：
   参数名 说明     server 获取 server 信息，包括 version, OS, port 等信息   clients 获取 clients 信息，如客户端连接数等   memory 获取 server 的内存信息，包括当前内存消耗、内存使用峰值   persistence 获取 server 的持久化配置信息   stats 获取 server 的一些基本统计信息，如处理过的连接数量等   replication 获取 server 的主从配置信息   cpu 获取 server 的 CPU 使用信息   keyspace 获取 server 中各个 DB 的 key 的数量   cluster 获取集群节点信息，仅在开启集群后可见   commandstats 获取每种命令的统计信息，非常有用    slowlog命令 redis."><meta property="og:url" content="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/"><meta property="og:site_name" content="Heaven's Door"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Redis"><meta property="article:tag" content="高并发"><meta property="article:tag" content="主从复制"><meta property="article:tag" content="优化"><meta property="article:published_time" content="2016-11-26T14:01:02+00:00"><meta property="article:modified_time" content="2016-11-26T14:01:02+00:00"><meta property="og:image" content="https://leibnizhu.github.io/"><meta name=twitter:title content="Redis性能调优——Pipeline、主从复制、Lua脚本等"><meta name=twitter:description content="这篇也是组内分享的文档，整理了之前两篇Netty+Redis的文章，加入了一些Redis调优相关的命令和内容。
Redis性能瓶颈 TCP连接 Redis协议基于TCP/IP协议，受限于TCP连接建立的速度（三次握手等），及网络中数据传输的速度。
数据包大小 Redis官方的一项测试显示，对于1k~10k以下的数据，Redis的吞吐量变化并不明显，吞吐量曲线在1k~10k左右出现拐点，如下图。
单线程 Redis服务器为C语言编写，使用异步非阻塞IO，目前坚持使用单线程（可能出于线程锁的效率考虑）。对于高并发访问+多核CPU场景而言，并不能充分使用CPU资源，可能发生某核心占用率很高，其他核心空闲，但Redis请求阻塞在队列中的情况。
搭建Redis集群可以解决该问题，但集群节点间访问引起的网络IO延时又带来新的问题。
Redis性能监控/测试 info命令 redis-cli中输入info可以显示当前Redis服务器的全部状态信息。这些信息按照内容被分成了很多部分，可以用额外的参数来单独获取，如下：
   参数名 说明     server 获取 server 信息，包括 version, OS, port 等信息   clients 获取 clients 信息，如客户端连接数等   memory 获取 server 的内存信息，包括当前内存消耗、内存使用峰值   persistence 获取 server 的持久化配置信息   stats 获取 server 的一些基本统计信息，如处理过的连接数量等   replication 获取 server 的主从配置信息   cpu 获取 server 的 CPU 使用信息   keyspace 获取 server 中各个 DB 的 key 的数量   cluster 获取集群节点信息，仅在开启集群后可见   commandstats 获取每种命令的统计信息，非常有用    slowlog命令 redis."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://leibnizhu.github.io/"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu4af873b90feb2f44d14cf5fcf42d034c_7593_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Heaven's Door</a></h1><h2 class=site-description>That cold black cloud is comin' down, Feels like I'm knockin' on heaven's door…</h2></div></header><ol class=social-menu><li><a href=https://leibnizhu.github.io title=Home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg></a></li><li><a href=https://github.com/leibnizhu target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:leibnizhu@gmail.com target=_blank title=Email><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-gmail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=https://leibnizhu.github.io/running target=_blank title=Running><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-run" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="13" cy="4" r="1"/><path d="M4 17l5 1 .75-1.5"/><path d="M15 21v-4l-4-3 1-6"/><path d="M7 12V9l5-1 3 3 3 1"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/About/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li><a href=/Links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>Links</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/>Redis性能调优——Pipeline、主从复制、Lua脚本等</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Nov 26, 2016</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>2 minute read</time></div></footer></div></header><section class=article-content><p>这篇也是组内分享的文档，整理了之前两篇Netty+Redis的文章，加入了一些Redis调优相关的命令和内容。</p><h1 id=redis性能瓶颈>Redis性能瓶颈</h1><h2 id=tcp连接>TCP连接</h2><p>Redis协议基于TCP/IP协议，受限于TCP连接建立的速度（三次握手等），及网络中数据传输的速度。</p><h2 id=数据包大小>数据包大小</h2><p>Redis官方的一项测试显示，对于1k~10k以下的数据，Redis的吞吐量变化并不明显，吞吐量曲线在1k~10k左右出现拐点，如下图。<br><img src=/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/1.png width=662 height=461 srcset="/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/1_huae3739b158ac574ede9203810d0e3c4f_14804_480x0_resize_box_3.png 480w, /p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/1_huae3739b158ac574ede9203810d0e3c4f_14804_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=143 data-flex-basis=344px></p><h2 id=单线程>单线程</h2><p>Redis服务器为C语言编写，使用异步非阻塞IO，目前坚持使用单线程（可能出于线程锁的效率考虑）。对于高并发访问+多核CPU场景而言，并不能充分使用CPU资源，可能发生某核心占用率很高，其他核心空闲，但Redis请求阻塞在队列中的情况。<br>搭建Redis集群可以解决该问题，但集群节点间访问引起的网络IO延时又带来新的问题。</p><h1 id=redis性能监控测试>Redis性能监控/测试</h1><h2 id=info命令>info命令</h2><p>redis-cli中输入info可以显示当前Redis服务器的全部状态信息。这些信息按照内容被分成了很多部分，可以用额外的参数来单独获取，如下：</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>参数名</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>server</td><td style=text-align:left>获取 server 信息，包括 version, OS, port 等信息</td></tr><tr><td style=text-align:left>clients</td><td style=text-align:left>获取 clients 信息，如客户端连接数等</td></tr><tr><td style=text-align:left>memory</td><td style=text-align:left>获取 server 的内存信息，包括当前内存消耗、内存使用峰值</td></tr><tr><td style=text-align:left>persistence</td><td style=text-align:left>获取 server 的持久化配置信息</td></tr><tr><td style=text-align:left>stats</td><td style=text-align:left>获取 server 的一些基本统计信息，如处理过的连接数量等</td></tr><tr><td style=text-align:left>replication</td><td style=text-align:left>获取 server 的主从配置信息</td></tr><tr><td style=text-align:left>cpu</td><td style=text-align:left>获取 server 的 CPU 使用信息</td></tr><tr><td style=text-align:left>keyspace</td><td style=text-align:left>获取 server 中各个 DB 的 key 的数量</td></tr><tr><td style=text-align:left>cluster</td><td style=text-align:left>获取集群节点信息，仅在开启集群后可见</td></tr><tr><td style=text-align:left>commandstats</td><td style=text-align:left>获取每种命令的统计信息，非常有用</td></tr></tbody></table></div><h2 id=slowlog命令>slowlog命令</h2><p>redis.conf中配置：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  slowlog-log-slower-than <span style=color:#f99b15>10000</span>
</span></span><span style=display:flex><span>  slowlog-max-len <span style=color:#f99b15>128</span>
</span></span></code></pre></div><p>意为：如果一条命令的响应时间超过了 10000us (即 10ms) ，那么将会作为 &ldquo;slow command&rdquo; 被记录，并且将只保留最新的128条记录。<br>在redis-cli中使用slowlog get N可以显示最新产生的N条慢操作：<br><img src=/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/2.png width=278 height=91 srcset="/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/2_hue73097dbe905c3b1c2195a46cef04135_3972_480x0_resize_box_3.png 480w, /p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/2_hue73097dbe905c3b1c2195a46cef04135_3972_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=305 data-flex-basis=733px><br>每条语句有四个描述字段，分别表示慢日志序号（最新的记录被展示在最前面）、这条记录被记录时的时间戳、这条命令的响应时间（单位：us 微秒）、这条命令的内容。<br>可以根据slowlog的记录优化对应的语句。</p><h2 id=bigkeys命令>bigkeys命令</h2><p>使用方法：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>redis-cli -h &lt;host&gt; -p &lt;port&gt; --bigkeys
</span></span></code></pre></div><p>这条命令会从指定的 Redis DB 中持续采样，实时输出当时得到的 value 占用空间最大的 key 值，并在最后给出各种数据结构的 biggest key 的总结报告，如下图：<br><img src=/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/3.png width=673 height=646 srcset="/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/3_hub089a628b13afa38bffb2e2c4121c535_64570_480x0_resize_box_3.png 480w, /p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/3_hub089a628b13afa38bffb2e2c4121c535_64570_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=104 data-flex-basis=250px></p><h2 id=latency命令>latency命令</h2><p>使用方法：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>redis-cli -h &lt;host&gt; -p &lt;port&gt; --latency-history
</span></span><span style=display:flex><span>redis-cli -h &lt;host&gt; -p &lt;port&gt; --latency
</span></span></code></pre></div><p>区别仅在于：前者每隔15秒生成一条记录（这15秒内的测试结果），后者持续更新测试结果，如下图：<br><img src=/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/4.png width=652 height=133 srcset="/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/4_hu8eb1b28e9fc83dee92cfb5f4d9720d49_15842_480x0_resize_box_3.png 480w, /p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/4_hu8eb1b28e9fc83dee92cfb5f4d9720d49_15842_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=490 data-flex-basis=1176px></p><h2 id=redis-benchmark测试>redis-benchmark测试</h2><p>使用方法：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>redis-benchmark -h &lt;host&gt; -p &lt;port&gt; -c &lt;并发数&gt; -n &lt;请求次数&gt;
</span></span></code></pre></div><p>执行后，redis-benchmark会对各个命令分别进行测试，测试结果较长，在此截取部分如下：<br><img src=/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/5.png width=348 height=214 srcset="/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/5_hu3a941fce91b3a5aed7470d18b62238b8_6920_480x0_resize_box_3.png 480w, /p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/5_hu3a941fce91b3a5aed7470d18b62238b8_6920_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=162 data-flex-basis=390px></p><h2 id=第三方统计分析工具redis-stat>第三方统计分析工具redis-stat</h2><p>redis-stat采用ruby开发，利用redis-cli info 提供的原始数据，给用户提供基于文本列表或web图表方式展现的各种关键数据。
redis-stat 开源网址: <a class=link href=https://github.com/junegunn/redis-stat target=_blank rel=noopener>https://github.com/junegunn/redis-stat</a><br><img src=/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/6.png width=687 height=366 srcset="/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/6_hu80e03b156dadeb75c088820daa26894d_25906_480x0_resize_box_3.png 480w, /p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/6_hu80e03b156dadeb75c088820daa26894d_25906_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=187 data-flex-basis=450px></p><h1 id=redis性能调优>Redis性能调优</h1><h2 id=使用pipeline>使用Pipeline</h2><p>对于Redis读写，有很大一部分的耗时是在网络IO上，尤其是Redis(集群)与应用不在一台服务器上时；此时，对于一些连续的操作，尽量使用pipeline批处理。若批量的命令使用到的key要求在执行过程中不被其他请求修改，则需要用redis事务，效率还是比pipeline低。</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Jedis jedis <span style=color:#5bc4bf>=</span> RedisUtils<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getSingleJedis</span><span style=color:#5bc4bf>(</span><span style=color:#815ba4>false</span><span style=color:#5bc4bf>);</span><span style=color:#776e71>//获取Jedis连接
</span></span></span><span style=display:flex><span><span style=color:#776e71></span>Pipeline pl <span style=color:#5bc4bf>=</span> jedis<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>pipelined</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>//获取Pipeline
</span></span></span><span style=display:flex><span><span style=color:#776e71></span>Response<span style=color:#5bc4bf>&lt;</span>String<span style=color:#5bc4bf>&gt;</span> resp1 <span style=color:#5bc4bf>=</span> pl<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>get</span><span style=color:#5bc4bf>(</span><span style=color:#ef6155>“</span>key1<span style=color:#ef6155>”</span><span style=color:#5bc4bf>);</span><span style=color:#776e71>//Pipeline压入命令并保存Response引用
</span></span></span><span style=display:flex><span><span style=color:#776e71></span>Response<span style=color:#5bc4bf>&lt;</span>String<span style=color:#5bc4bf>&gt;</span> resp2 <span style=color:#5bc4bf>=</span> pl<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>get</span><span style=color:#5bc4bf>(</span><span style=color:#ef6155>“</span>key2<span style=color:#ef6155>”</span><span style=color:#5bc4bf>);</span>
</span></span><span style=display:flex><span>pl<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>sync</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>//Pipeline执行批处理
</span></span></span><span style=display:flex><span><span style=color:#776e71></span>System<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>out</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>println</span><span style=color:#5bc4bf>(</span><span style=color:#ef6155>“</span>key1<span style=color:#ef6155>’</span>s value <span style=color:#5bc4bf>=</span> <span style=color:#ef6155>”</span> <span style=color:#5bc4bf>+</span> resp1<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>get</span><span style=color:#5bc4bf>());</span><span style=color:#776e71>//从Response获取执行结果
</span></span></span><span style=display:flex><span><span style=color:#776e71></span>System<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>out</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>println</span><span style=color:#5bc4bf>(</span><span style=color:#ef6155>“</span>key2<span style=color:#ef6155>’</span>s value <span style=color:#5bc4bf>=</span> <span style=color:#ef6155>”</span> <span style=color:#5bc4bf>+</span> resp2<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>get</span><span style=color:#5bc4bf>());</span>
</span></span><span style=display:flex><span>RedisUtils<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>close</span><span style=color:#5bc4bf>(</span>pl<span style=color:#5bc4bf>);</span><span style=color:#776e71>//关闭Pipeline
</span></span></span><span style=display:flex><span><span style=color:#776e71></span>RedisUtils<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>close</span><span style=color:#5bc4bf>(</span>jedis<span style=color:#5bc4bf>);</span><span style=color:#776e71>//关闭Jedis连接
</span></span></span></code></pre></div><p>要注意的是Pipeline一次传输的key或数据也不宜过多，参考本文1.2小节。</p><h2 id=使用lua脚本>使用Lua脚本</h2><p>灵活利用Lua脚本，可减少Redis的网络IO。Redis支持在服务器上运行Lua脚本完成一些简单运算。Redis尽管对Lua脚本有很多限制，但的确能提高效率，对于一些Redis原生API不能满足的批量操作，比如读取多个key再进行简单计算，如果将这些key的值分别读取到本地，再进行计算，会发生多次网络IO，那么可以用上面的pipeline，而效率更高的方法是将这些计算写成Lua脚本。<br>我们的RTB目前使用Lua脚本的流程如下：</p><ol><li>配置一个监听Servlet上下文初始化的Listener（com.turingdi.rtb.service. PropertiesLoadListener），执行读取配置文件、Redis连接等初始化操作；</li><li>/该Listener初始化Redis时，将指定的多个Lua脚本文件读入内存（com.turingdi.rtb.utils.RedisUtils的loadScripts()）；</li><li>使用Redis的SCRIPTLOAD命令，将Lua脚本加载到Redis服务器，返回一个SHA码，保存到RedisUtils类中；</li><li>竞价过程中需要调用Lua脚本时，调用Redis的EVALSHA命令，使用初始化时拿到的SHA进行Lua脚本调用，返回计算结果。</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#776e71>--计算QPS，QPS这个key只保留1s，不存在的时候设置为1并设置生命周期为1，存在的时候直接加1</span>
</span></span><span style=display:flex><span><span style=color:#815ba4>local</span> isExist <span style=color:#5bc4bf>=</span> redis.call(<span style=color:#48b685>&#39;EXISTS&#39;</span>, <span style=color:#48b685>&#39;QPS&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#815ba4>if</span> isExist <span style=color:#5bc4bf>==</span> <span style=color:#f99b15>0</span> <span style=color:#815ba4>then</span>
</span></span><span style=display:flex><span>  redis.call(<span style=color:#48b685>&#39;INCR&#39;</span>, <span style=color:#48b685>&#39;QPS&#39;</span>)
</span></span><span style=display:flex><span>  redis.call(<span style=color:#48b685>&#39;EXPIRE&#39;</span>, <span style=color:#48b685>&#39;QPS&#39;</span>, <span style=color:#48b685>&#39;1&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#815ba4>else</span>
</span></span><span style=display:flex><span>  redis.call(<span style=color:#48b685>&#39;INCR&#39;</span>, <span style=color:#48b685>&#39;QPS&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#815ba4>end</span>
</span></span><span style=display:flex><span><span style=color:#776e71>--处理请求数和响应数的统计</span>
</span></span><span style=display:flex><span>redis.call(<span style=color:#48b685>&#39;INCR&#39;</span>, KEYS[<span style=color:#f99b15>1</span>])
</span></span><span style=display:flex><span><span style=color:#815ba4>if</span> ARGV[<span style=color:#f99b15>1</span>] <span style=color:#5bc4bf>==</span> <span style=color:#48b685>&#39;1&#39;</span> <span style=color:#815ba4>then</span>
</span></span><span style=display:flex><span>  redis.call(<span style=color:#48b685>&#39;INCR&#39;</span>, KEYS[<span style=color:#f99b15>2</span>])
</span></span><span style=display:flex><span><span style=color:#815ba4>end</span>
</span></span></code></pre></div><p>本文不对Lua脚本进行详细阐述，有需要的可以参照以下网页/文档：</p><ul><li><a class=link href=http://redisdoc.com/script/index.html target=_blank rel=noopener>http://redisdoc.com/script/index.html</a></li><li><a class=link href=https://www.oschina.net/translate/intro-to-lua-for-redis-programmers target=_blank rel=noopener>https://www.oschina.net/translate/intro-to-lua-for-redis-programmers</a></li><li><a class=link href=http://origin.redisbook.com/feature/scripting.html target=_blank rel=noopener>http://origin.redisbook.com/feature/scripting.html</a></li><li><a class=link href=http://wiki.jikexueyuan.com/project/redis/lua.html target=_blank rel=noopener>http://wiki.jikexueyuan.com/project/redis/lua.html</a></li></ul><h2 id=使用本地的redis>使用本地的Redis</h2><p>Redis尽量放在本地，减少网络IO时间；对相应时间要求高的，尽量不要用云服务商提供的Redis服务，读写速度比不上本地的。</p><h2 id=主从复制读写分离>主从复制/读写分离</h2><p>Redis放在本地，在服务器集群环境下就有数据同步的问题。之前尝试过很多方案，Redis自己的Ruby集群、Twitter的Twemproxy等等，都不适合RTB使用——这些集群更多地考虑可用性和数据分片、扩容性，但对一些多键操作支持很差，而且也有各种缺陷（如使用Redis自带的Ruby集群，至少3主3从，可以建好3主3从的集群之后，手动移动Slot到同一台主机，删除其他主机，变成1主3从，但这个集群一旦关闭就无法启动）。<br>考虑到RTB使用的Redis读多写少，所以最后使用的方案是Redis自带的主从复制，集群的不同的服务器之间只需要一台主机作为Redis主机，其他服务器的Redis服务设置slaveof属性，作为其从机。此外，可以将从机的只读属性设为no，但往Slave写入的数据会在下一次同步的时候被Master的数据所覆盖——这样做的目的在于写入一些临时缓存变量。<br>redis.conf配置如下：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  slaveof &lt;Master IP&gt; &lt;Master端口&gt;
</span></span><span style=display:flex><span>  slave-read-only no
</span></span></code></pre></div><p>只有一台服务器的情况下，如果是多核服务器（16核及以上），由于Redis是单线程的，只能利用一个CPU内核，只开一个Redis服务实例可能压力很大（可以从CPU占用看出来），此时也可以使用上面提到的主从复制功能，在同一台服务器上开启多个Redis实例分担查询压力，提高并发性能。<br>Linux系统中，可以使用：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>taskset -cp <span style=color:#5bc4bf>[</span>CPU核心号码，从0开始<span style=color:#5bc4bf>]</span> <span style=color:#5bc4bf>[</span>要执行的命令<span style=color:#5bc4bf>]</span>
</span></span></code></pre></div><p>来指定要执行的命令在哪些CPU内核上运行，在多核服务器上，可以合理利用此命令来分配CPU资源，如指定多个Redis和Netty分别运行在多个内核上，并指定哪个Netty服务使用哪个Redis服务（需要自己编写Netty服务，读取配置文件，使用不同端口的Redis服务），避免资源浪费和拥挤。<br>目前RTB在一台服务器上部署了一个Master节点（端口6660）和5个Slave节点（端口6661-6665），即只有一个对外可写入的Redis服务，其他Redis服务只能读，保证了读的性能。启动的脚本如下：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#776e71>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#776e71></span>kill -9 <span style=color:#815ba4>$(</span>ps -ef | grep redis-server | grep -v grep | awk <span style=color:#48b685>&#39;{print $2}&#39;</span><span style=color:#815ba4>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cd /usr/local/redis/6660
</span></span><span style=display:flex><span>taskset -c <span style=color:#f99b15>0</span> redis-server redis.conf
</span></span><span style=display:flex><span>cd /usr/local/redis/6661
</span></span><span style=display:flex><span>taskset -c <span style=color:#f99b15>1</span> redis-server redis.conf
</span></span><span style=display:flex><span>…………
</span></span><span style=display:flex><span>cd /usr/local/redis/6665
</span></span><span style=display:flex><span>taskset -c <span style=color:#f99b15>5</span> redis-server redis.conf
</span></span></code></pre></div><h2 id=计算缓存>计算缓存</h2><p>Redis指令的优化及自定义计算缓存。利用SLOWLOG我们可以找到执行比较慢的命令，从而进行优化。<br>比如RTB系统在测试一段时间之后，通过SLOWLOG命令得知耗时较长的都是用户人群标签的并集操作，而这个操作与请求的具体内容有关。所以后来设定了一个计算缓存，通过EXPIRE命令设置缓存的生命周期（随着时间推移，人群标签的计算结果是不一样的，需要定时更新），每次新的请求在计算这一步时，先查询缓存中是否存在计算结果，存在的话直接读取，不存在（全新的计算或旧的已过期）则重新计算并放入运算缓存。（详见com.turingdi.rtb.service.CampaignService）</p><h2 id=压缩key和value>压缩key和value</h2><p>在数据量大的情况下，压缩key和value的长度不管对存储还是网络传输都有利。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/Redis/>Redis</a>
<a href=/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/>高并发</a>
<a href=/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/>主从复制</a>
<a href=/tags/%E4%BC%98%E5%8C%96/>优化</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under Apache License 2.0</span></section></footer></article><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//leibnizhu.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2016 -
2022 Heaven's Door</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.11.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#tcp连接>TCP连接</a></li><li><a href=#数据包大小>数据包大小</a></li><li><a href=#单线程>单线程</a></li></ol><ol><li><a href=#info命令>info命令</a></li><li><a href=#slowlog命令>slowlog命令</a></li><li><a href=#bigkeys命令>bigkeys命令</a></li><li><a href=#latency命令>latency命令</a></li><li><a href=#redis-benchmark测试>redis-benchmark测试</a></li><li><a href=#第三方统计分析工具redis-stat>第三方统计分析工具redis-stat</a></li></ol><ol><li><a href=#使用pipeline>使用Pipeline</a></li><li><a href=#使用lua脚本>使用Lua脚本</a></li><li><a href=#使用本地的redis>使用本地的Redis</a></li><li><a href=#主从复制读写分离>主从复制/读写分离</a></li><li><a href=#计算缓存>计算缓存</a></li><li><a href=#压缩key和value>压缩key和value</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>