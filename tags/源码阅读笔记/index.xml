<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码阅读笔记 on Heaven's Door</title><link>https://leibnizhu.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link><description>Recent content in 源码阅读笔记 on Heaven's Door</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 30 Nov 2017 11:53:14 +0800</lastBuildDate><atom:link href="https://leibnizhu.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>Tomcat8源码读后感</title><link>https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/</link><pubDate>Thu, 30 Nov 2017 11:53:14 +0800</pubDate><guid>https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/</guid><description>&lt;img src="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/sundown2.jpg" alt="Featured image of post Tomcat8源码读后感" />&lt;p>源码版本：&lt;code>Tomcat 8.0.41&lt;/code>&lt;/p>
&lt;h3 id="request和response的门面模式">Request和Response的门面模式&lt;/h3>
&lt;p>&lt;img src="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/request.png"
width="180"
height="274"
srcset="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/request_hua75cf0cc9e85cc522889505be9bf757c_9924_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/request_hua75cf0cc9e85cc522889505be9bf757c_9924_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="65"
data-flex-basis="157px"
> &lt;img src="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/response.png"
width="194"
height="275"
srcset="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/response_hu6ca6fcfc53f1885b949cdbeece85a962_10304_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/response_hu6ca6fcfc53f1885b949cdbeece85a962_10304_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="70"
data-flex-basis="169px"
>&lt;br>
从UML图可以看到，Tomcat中&lt;code>HttpServletRequest&lt;/code>和&lt;code>HttpServletResponse&lt;/code>的实现类是&lt;code>org.apache.catalina.connector.Request&lt;/code>和&lt;code>org.apache.catalina.connector.Response&lt;/code>，但实际提供给Servlet的时候用的是门面类&lt;code>RequestFacade&lt;/code>和&lt;code>ResponseFacade&lt;/code>。这是因为实现类里面的public方法比接口的多，而且可能涉及到安全问题，如果Servlet直接将其强转成实现类，是可以访问这些方法的，存在安全问题，因为使用了门面模式，将这些方法隐藏起来。&lt;/p>
&lt;h3 id="统一日志消息处理">统一日志消息处理&lt;/h3>
&lt;p>Tomcat8使用&lt;code>org.apache.catalina.tribes.util.StringManager&lt;/code>对日志消息进行统一处理，每个包一般都有一个&lt;code>LocalStrings.properties&lt;/code>文件，需要调用这些日志信息的类，会维护一个&lt;code>StringManager&lt;/code>的实例，初始化时以当前包名为参数，以获取当前包对应的&lt;code>LocalStrings.properties&lt;/code>文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#06b6ef">StringManager&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String packageName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> Hashtable&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>String&lt;span style="color:#5bc4bf">,&lt;/span> StringManager&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> managers &lt;span style="color:#5bc4bf">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">new&lt;/span> Hashtable&lt;span style="color:#5bc4bf">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * Get the StringManager for a particular package. If a manager for
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * a package already exists, it will be reused, else a new
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * StringManager will be created and returned.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * @param packageName The package name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#815ba4">synchronized&lt;/span> StringManager &lt;span style="color:#06b6ef">getManager&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String packageName&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringManager mgr &lt;span style="color:#5bc4bf">=&lt;/span> managers&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>packageName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>mgr &lt;span style="color:#5bc4bf">==&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mgr &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">new&lt;/span> StringManager&lt;span style="color:#5bc4bf">(&lt;/span>packageName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> managers&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>packageName&lt;span style="color:#5bc4bf">,&lt;/span> mgr&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> mgr&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/* For Example */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">protected&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> StringManager sm &lt;span style="color:#5bc4bf">=&lt;/span> StringManager&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">getManager&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Constants&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">Package&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到它使用了&lt;code>Hashtable&lt;/code>来维护每个包对应的&lt;code>StringManager&lt;/code>单例。&lt;br>
然后在需要读取消息的时候调用&lt;code>StringManager&lt;/code>的&lt;code>getString(String key)&lt;/code>方法，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>log&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">info&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>sm&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">getString&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;receiverBase.socket.bind&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span> addr&lt;span style="color:#5bc4bf">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="请求参数等的懒解析">请求参数等的懒解析&lt;/h3>
&lt;p>为了提高效率，请求参数在第一次调用&lt;code>public String getParameter(String name)&lt;/code>、&lt;code>public Enumeration&amp;lt;String&amp;gt; getParameterNames()&lt;/code>等方法的时候才会解析，如果整个请求响应处理过程中都没有调用相关方法的话，请求参数将不会被解析，因为字符串处理的消耗不低。其他的一些属性也有类似的处理。主要的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * Request parameters parsed flag.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">protected&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> parametersParsed &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">false&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * Return the value of the specified request parameter, if any; otherwise,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * return &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;. If there is more than one value defined,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * return only the first one.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * @param name Name of the desired request parameter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> String &lt;span style="color:#06b6ef">getParameter&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String name&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(!&lt;/span>parametersParsed&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parseParameters&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> coyoteRequest&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">getParameters&lt;/span>&lt;span style="color:#5bc4bf">().&lt;/span>&lt;span style="color:#06b6ef">getParameter&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>name&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * Returns a &amp;lt;code&amp;gt;Map&amp;lt;/code&amp;gt; of the parameters of this request.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * Request parameters are extra information sent with the request.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * For HTTP servlets, parameters are contained in the query string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * or posted form data.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * @return A &amp;lt;code&amp;gt;Map&amp;lt;/code&amp;gt; containing parameter names as keys
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * and parameter values as map values.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>String&lt;span style="color:#5bc4bf">,&lt;/span> String&lt;span style="color:#5bc4bf">[]&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">getParameterMap&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>parameterMap&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">isLocked&lt;/span>&lt;span style="color:#5bc4bf">())&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> parameterMap&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Enumeration&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> enumeration &lt;span style="color:#5bc4bf">=&lt;/span> getParameterNames&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">while&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>enumeration&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hasMoreElements&lt;/span>&lt;span style="color:#5bc4bf">())&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#5bc4bf">=&lt;/span> enumeration&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">nextElement&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#5bc4bf">[]&lt;/span> values &lt;span style="color:#5bc4bf">=&lt;/span> getParameterValues&lt;span style="color:#5bc4bf">(&lt;/span>name&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parameterMap&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>name&lt;span style="color:#5bc4bf">,&lt;/span> values&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parameterMap&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">setLocked&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#815ba4">true&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> parameterMap&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * Return the names of all defined request parameters for this request.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> Enumeration&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">getParameterNames&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(!&lt;/span>parametersParsed&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parseParameters&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> coyoteRequest&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">getParameters&lt;/span>&lt;span style="color:#5bc4bf">().&lt;/span>&lt;span style="color:#06b6ef">getParameterNames&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * Parse request parameters.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">protected&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">parseParameters&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parametersParsed &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">true&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">/*………具体的解析处理，在此省略………*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>ParameterMap&lt;/code>是一个继承了&lt;code>LinkedHashMap&lt;/code>的类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">ParameterMap&lt;/span>&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> LinkedHashMap&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="connector连接器">Connector连接器&lt;/h3>
&lt;p>&lt;img src="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/connector.png"
width="526"
height="200"
srcset="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/connector_hu63d16e56f15764500da85ffad2275921_10488_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/connector_hu63d16e56f15764500da85ffad2275921_10488_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="263"
data-flex-basis="631px"
>
Tomcat8主要有四个Connector，分别为&lt;code>Http11Protocol&lt;/code>、&lt;code>Http11NioProtocol&lt;/code>、&lt;code>Http11Nio2Protocol&lt;/code>、&lt;code>Http11AprProtocol&lt;/code>，UML如上图所示，内容比较多，暂时不讨论了。&lt;/p>
&lt;h3 id="tomcat容器层次">Tomcat容器层次&lt;/h3>
&lt;p>Tomcat中有四个层次的容器：&lt;/p>
&lt;ul>
&lt;li>Engine：整个Catalina Servlet引擎&lt;/li>
&lt;li>Host：包含一个或多个Context容器的虚拟主机&lt;/li>
&lt;li>Context：表示一个Web应用程序，包含一个或多个Wrapper&lt;/li>
&lt;li>Wrapper：表示一个独立的Servlet&lt;/li>
&lt;/ul>
&lt;p>以上四个类均实现了&lt;code>org.apache.catalina.Container&lt;/code>接口，标准实现分别为&lt;code>org.apache.catalina.core&lt;/code>包中的&lt;code>StandardEngine&lt;/code>、&lt;code>StandardHost&lt;/code>、&lt;code>StandardContext&lt;/code>、&lt;code>StandardWrapper&lt;/code>。
&lt;img src="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/container.png"
width="1144"
height="396"
srcset="https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/container_hub792b78ab73a6bdeeca26693cee98c0c_40450_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Tomcat8%E6%BA%90%E7%A0%81%E8%AF%BB%E5%90%8E%E6%84%9F/container_hub792b78ab73a6bdeeca26693cee98c0c_40450_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="288"
data-flex-basis="693px"
>&lt;/p>
&lt;h3 id="pipeline管道">Pipeline管道&lt;/h3>
&lt;p>(尚未完工)
&lt;code>org.apache.catalina.valves.AccessLogValve&lt;/code>&lt;/p></description></item><item><title>HashMap线程安全性讨论</title><link>https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/</link><pubDate>Tue, 01 Aug 2017 16:36:39 +0800</pubDate><guid>https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/</guid><description>&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/sundown.png" alt="Featured image of post HashMap线程安全性讨论" />&lt;h1 id="hashmap线程安全性讨论">HashMap线程安全性讨论&lt;/h1>
&lt;p>去年写的 &lt;a class="link" href="https://leibnizhu.github.io/2016/12/24/HashMap%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0/" >HashMap源码阅读笔记&lt;/a> 分析了JDK8 中的&lt;code>HashMap&lt;/code>源码的&lt;code>get()&lt;/code>和&lt;code>put()&lt;/code>两大方法，当时并没有考虑到&lt;code>HashMap&lt;/code>的线程安全性。&lt;br>
众所周知，&lt;code>HashMap&lt;/code>并非线程安全的，但在 &lt;em>JDK8&lt;/em> 之前，&lt;code>HashMap&lt;/code>的线程安全不但体现在多线程读写可能出现数据错误，还存在一个多线程扩容导致的死循环Bug。本文将讨论这一Bug，及在 &lt;em>JDK8&lt;/em> 中的修复，以及相关的&lt;code>ConcurrentHashMap&lt;/code>。&lt;/p>
&lt;h2 id="jdk8-之前的多线程扩容bug">&lt;em>JDK8&lt;/em> 之前的多线程扩容Bug&lt;/h2>
&lt;h3 id="扩容代码解析">扩容代码解析&lt;/h3>
&lt;p>我们直接看JDK7 中&lt;code>HashMap&lt;/code>的扩容方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">resize&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> newCapacity&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">[]&lt;/span> oldTable &lt;span style="color:#5bc4bf">=&lt;/span> table&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fec418">int&lt;/span> oldCapacity &lt;span style="color:#5bc4bf">=&lt;/span> oldTable&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">length&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//最大长度限制在Integer.MAX_VALUE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>oldCapacity &lt;span style="color:#5bc4bf">==&lt;/span> MAXIMUM_CAPACITY&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threshold &lt;span style="color:#5bc4bf">=&lt;/span> Integer&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">MAX_VALUE&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">[]&lt;/span> newTable &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">new&lt;/span> Entry&lt;span style="color:#5bc4bf">[&lt;/span>newCapacity&lt;span style="color:#5bc4bf">];&lt;/span>&lt;span style="color:#776e71">//按新的长度分配哈希表数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> transfer&lt;span style="color:#5bc4bf">(&lt;/span>newTable&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//将旧的哈希表重新分配到新哈希表里，可能导致环链
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> table &lt;span style="color:#5bc4bf">=&lt;/span> newTable&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//将新的哈希表复制到HashMap的table变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> threshold &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span>&lt;span style="color:#5bc4bf">)(&lt;/span>newCapacity &lt;span style="color:#5bc4bf">*&lt;/span> loadFactor&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//按新容量更新扩容阈值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">transfer&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Entry&lt;span style="color:#5bc4bf">[]&lt;/span> newTable&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">[]&lt;/span> src &lt;span style="color:#5bc4bf">=&lt;/span> table&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fec418">int&lt;/span> newCapacity &lt;span style="color:#5bc4bf">=&lt;/span> newTable&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">length&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">for&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> j &lt;span style="color:#5bc4bf">=&lt;/span> 0&lt;span style="color:#5bc4bf">;&lt;/span> j &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span> src&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">length&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span> j&lt;span style="color:#5bc4bf">++)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> e &lt;span style="color:#5bc4bf">=&lt;/span> src&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>e &lt;span style="color:#5bc4bf">!=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> src&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//关键部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">do&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> next &lt;span style="color:#5bc4bf">=&lt;/span> e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//获得原来链表中的下一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#fec418">int&lt;/span> i &lt;span style="color:#5bc4bf">=&lt;/span> indexFor&lt;span style="color:#5bc4bf">(&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hash&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span> newCapacity&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//获取扩容后新的下标，可能跟原来一样，或者比原来的大newCapacity/2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> newTable&lt;span style="color:#5bc4bf">[&lt;/span>i&lt;span style="color:#5bc4bf">];&lt;/span>&lt;span style="color:#776e71">//设置当前元素在链表的下一个元素为新哈希表对应位置原来的元素，也就是说旧元素会被往后推，该链表上最早读取的元素会成为尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> newTable&lt;span style="color:#5bc4bf">[&lt;/span>i&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> e&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//哈希表的入口改为当前元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> e &lt;span style="color:#5bc4bf">=&lt;/span> next&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//遍历原来链表的下一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span> &lt;span style="color:#815ba4">while&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>e &lt;span style="color:#5bc4bf">!=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>工作原理在上面代码的注释里说得比较清楚了，值得注意的是，&lt;code>transfer(newTable)&lt;/code>之后的新哈希表里，每个链表的顺序都与扩容之前的刚好相反，这一点直接注定了会出现多线程扩容Bug。&lt;/p>
&lt;h3 id="扩容时的多线程死循环bug">扩容时的多线程死循环Bug&lt;/h3>
&lt;p>如上面的分析，由于扩容后每个链表的顺序都调转了，因此定性地分析，多线程同时触发扩容的时候，有可能其中一个线程已经把链表调转了，而另一个线程获取了链表调转前的状态，重新获取到时间片的时候，再次翻转，导致next引用的赋值出错，链表中构成环；这样在调用&lt;code>get()&lt;/code>方法的时候，进入到这个链表就会陷入死循环。
具体的举例分析，可以参考美团点评技术团队的文章 &lt;a class="link" href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener"
>Java 8系列之重新认识HashMap&lt;/a> ，在此贴出关键的部分：&lt;/p>
&lt;blockquote>
&lt;p>代码例子如下(便于理解，仍然使用JDK1.7的环境)：&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">HashMapInfiniteLoop&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> HashMap&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>Integer&lt;span style="color:#5bc4bf">,&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> map &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">new&lt;/span> HashMap&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>Integer&lt;span style="color:#5bc4bf">,&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;(&lt;/span>2&lt;span style="color:#ef6155">，&lt;/span>0&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">75f&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">main&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String&lt;span style="color:#5bc4bf">[]&lt;/span> args&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>5&lt;span style="color:#ef6155">，&lt;/span> &lt;span style="color:#48b685">&amp;#34;C&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">new&lt;/span> Thread&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;Thread1&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">run&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>7&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#48b685">&amp;#34;B&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">out&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">println&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>map&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}.&lt;/span>&lt;span style="color:#06b6ef">start&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">new&lt;/span> Thread&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;Thread2&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">run&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>3&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#48b685">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">out&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">println&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>map&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}.&lt;/span>&lt;span style="color:#06b6ef">start&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。&lt;/p>
&lt;p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。&lt;br>
&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3.png"
width="1388"
height="628"
srcset="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3_hu8c609b8e724bfb2c0290ec31e1a358b7_20420_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3_hu8c609b8e724bfb2c0290ec31e1a358b7_20420_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="530px"
>
注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。&lt;/p>
&lt;p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。&lt;br>
&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4.png"
width="1380"
height="522"
srcset="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4_hu4e735beccad0b142c011203082f64e5a_15190_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4_hu4e735beccad0b142c011203082f64e5a_15190_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="264"
data-flex-basis="634px"
>&lt;br>
&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5.png"
width="1374"
height="484"
srcset="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5_hu2621d6ffff8728bce2c216db713e4324_15188_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5_hu2621d6ffff8728bce2c216db713e4324_15188_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="283"
data-flex-basis="681px"
>&lt;br>
e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。&lt;br>
&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6.png"
width="1384"
height="482"
srcset="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6_hufeb79b1a930dbfa7f169a79531429de5_14874_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6_hufeb79b1a930dbfa7f169a79531429de5_14874_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="287"
data-flex-basis="689px"
>&lt;br>
于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。&lt;/p>
&lt;/blockquote>
&lt;h2 id="jdk8-如何修复多线程扩容bug">&lt;em>JDK8&lt;/em> 如何修复多线程扩容Bug&lt;/h2>
&lt;p>正如我在 &lt;a class="link" href="https://leibnizhu.github.io/2016/12/24/HashMap%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0/" >HashMap源码阅读笔记&lt;/a> 中分析到的，&lt;em>JDK8&lt;/em> 中&lt;code>Node&amp;lt;K,V&amp;gt;[] resize()&lt;/code>扩容方法利用了哈希表长度为2的幂，以及&lt;code>get()&lt;/code>方法对哈希值取低位的特性，结合每次扩容哈希表大小都增倍等特性，每次扩容，一个哈希桶里的元素在扩容后的位置，只会是原位置，或者原位置+原哈希表大小。&lt;br>
因此扩容的时候可以将一个哈希桶的扩容结果分为两个链表，还在原来位置的记为 &lt;em>低位链表&lt;/em>(我自己起的名字)，用&lt;code>loHead loTail&lt;/code>标记其头尾；扩容后分配到原位置+原哈希表大小的构成 &lt;em>高位链表&lt;/em>(同样是我自己起的名字)，用&lt;code>hiHead hiTail&lt;/code>标记其头尾。&lt;br>
具体实现的核心部分代码如下（省略了特殊容量处理、红黑树处理等等代码）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">final&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;[]&lt;/span> &lt;span style="color:#06b6ef">resize&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">/*…………省略前面代码…………*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>loHead&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>loTail&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//记录低位链表头尾位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>hiHead&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>hiTail&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//记录高位链表头尾位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>next&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//记录当前链表元素在原来链表中的下一个元素，便于下次循环使用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">//遍历哈希桶的链表，拆分成高位和低位链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">do&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hash&lt;/span>&lt;span style="color:#5bc4bf">&amp;amp;&lt;/span>oldCap&lt;span style="color:#5bc4bf">)==&lt;/span>0&lt;span style="color:#5bc4bf">){&lt;/span> &lt;span style="color:#776e71">//新增的有效哈希位为0，即当前元素扩容后分配到 低位链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>loTail&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#776e71">//低位链表尚未初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> loHead&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//设置低位链表头部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//低位链表尾部增加当前元素，以保持原链表顺序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> loTail&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//更新低位链表的尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">else&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span> &lt;span style="color:#776e71">//新增的有效哈希位为1，即当前元素扩容后分配到 高位链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>hiTail&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#776e71">//高低位链表尚未初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> hiHead&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//设置高位链表头部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//高位链表尾部增加当前元素，以保持原链表顺序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> hiTail&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//更新高位链表的尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">while&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">=&lt;/span>next&lt;span style="color:#5bc4bf">)!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//更新两个链表到哈希表中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>loTail&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span> &lt;span style="color:#776e71">//扩容后低位链表不为空，需要处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> loTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//低位链表设置尾部结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">]=&lt;/span>loHead&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//哈希桶设置链表入口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>hiTail&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span> &lt;span style="color:#776e71">//扩容后高位链表不为空，需要处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> hiTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//高位链表设置尾部结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">+&lt;/span>oldCap&lt;span style="color:#5bc4bf">]=&lt;/span>hiHead&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//哈希桶设置链表入口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">/*…………省略后面代码…………*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体处理的过程我在上面的注释里说得比较清楚了，包括代码之前的那段文字。&lt;br>
可以看到，扩容后，原来哈希桶的链表被拆分为两个，两个链表中的元素都能继续维持原有的顺序。这样就算在多线程环境下同时扩容，一个线程A读取链表状态后停止工作，另一个线程B对同一链表的前几个元素进行扩容分成两个链表，此时线程A恢复工作，由于线程B对链表元素的顺序没有发生变化，所以线程A恢复工作后只是重复了拆分链表的工作，而不会因为链表已被改变顺序而导致环的生成，因此不会发生死循环的问题。&lt;br>
也就是说 &lt;em>JDK8&lt;/em> 的&lt;code>HashMap&lt;/code>扩容方法不但效率提升了（根据哈希值特点拆分链表，红黑树），而且还维持了扩容前后的链表顺序，从而解决了多线程扩容使链表产生环，导致死循环的问题。&lt;/p>
&lt;h2 id="其他线程安全map">其他线程安全Map&lt;/h2>
&lt;h3 id="hashtable类">Hashtable类&lt;/h3>
&lt;p>类名叫&lt;code>Hashtable&lt;/code>不叫&lt;code>HashTable&lt;/code>真是逼死强迫症。这个类现在很少用了，从源码可以看到，它是在&lt;code>get() put()&lt;/code>等方法的声明里加了&lt;code>synchronized&lt;/code>关键字来实现多线程安全的，因此显然效率比较低。&lt;/p>
&lt;h3 id="collectionssynchronizedmap方法">Collections.synchronizedMap()方法&lt;/h3>
&lt;p>在&lt;code>Collections&lt;/code>工具类里有&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">synchronizedMap&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> m&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>方法，传入将普通的Map实例，返回一个线程安全的Map实例。实现方法也比较简单，返回的是&lt;code>Collections&lt;/code>的内部类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">SynchronizedMap&lt;/span>&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#815ba4">implements&lt;/span> Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;,&lt;/span> Serializable &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> m&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">// Backing Map
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> Object mutex&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">// Object on which to synchronize
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SynchronizedMap&lt;span style="color:#5bc4bf">(&lt;/span>Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> m&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">m&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> Objects&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">requireNonNull&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>m&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutex &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SynchronizedMap&lt;span style="color:#5bc4bf">(&lt;/span>Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> m&lt;span style="color:#5bc4bf">,&lt;/span> Object mutex&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">m&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> m&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">mutex&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> mutex&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> V &lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object key&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">synchronized&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>mutex&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>&lt;span style="color:#815ba4">return&lt;/span> m&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>key&lt;span style="color:#5bc4bf">);}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> V &lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>K key&lt;span style="color:#5bc4bf">,&lt;/span> V value&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">synchronized&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>mutex&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>&lt;span style="color:#815ba4">return&lt;/span> m&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>key&lt;span style="color:#5bc4bf">,&lt;/span> value&lt;span style="color:#5bc4bf">);}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">/*………省略其他方法，大同小异………*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>的实例。上面也给出了简要的类代码，实现的方法相当简单粗暴，由构造方法传入线程不安全的类实例，用一个锁（默认是自身，也可以在构造方法里传入），在各种&lt;code>Map&lt;/code>接口的方法里面使用这个锁对线程不安全的类实例方法进行同步，也就是一个包装的设计模式，用同步代码块包装原有方法。&lt;br>
显然这样得到的线程安全类的效率也不高。&lt;/p>
&lt;h3 id="concurrenthashmap类">ConcurrentHashMap类&lt;/h3>
&lt;p>&lt;em>JDK8&lt;/em> 之前的&lt;code>ConcurrentHashMap&lt;/code>使用Segment（锁段）提高同步的效率，而 &lt;em>JDK8&lt;/em> 开始利用CAS算法大大提高了实现线程安全的效率。有空要再写一篇博客分析一下&lt;code>ConcurrentHashMap&lt;/code>的源码。&lt;/p></description></item><item><title>LinkedList源码阅读笔记（JDK8）</title><link>https://leibnizhu.github.io/p/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/</link><pubDate>Mon, 31 Jul 2017 14:35:06 +0800</pubDate><guid>https://leibnizhu.github.io/p/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/</guid><description>&lt;img src="https://leibnizhu.github.io/p/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/night.png" alt="Featured image of post LinkedList源码阅读笔记（JDK8）" />&lt;h1 id="linkedlist源码阅读笔记">LinkedList源码阅读笔记&lt;/h1>
&lt;h2 id="继承结构">继承结构&lt;/h2>
&lt;p>&lt;img src="https://leibnizhu.github.io/p/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/LinkedList_UML.png"
width="658"
height="455"
srcset="https://leibnizhu.github.io/p/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/LinkedList_UML_hu0bbba6c5472c67862680e5e322c83415_25624_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/LinkedList_UML_hu0bbba6c5472c67862680e5e322c83415_25624_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;h2 id="成员变量">成员变量&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//记录长度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">transient&lt;/span> &lt;span style="color:#fec418">int&lt;/span> size &lt;span style="color:#5bc4bf">=&lt;/span> 0&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//第一个元素的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">transient&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> first&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//最后一个元素的指针（为了增加从尾部开始的速度，及支持一些增删改查尾部元素的方法）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">transient&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> last&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上成员变量都用了transient关键字避免被持久化。&lt;/p>
&lt;p>从继承结构来看，&lt;code>LinkedList&lt;/code>继承了&lt;code>AbstractSequentialList&lt;/code>，而&lt;code>AbstractSequentialList&lt;/code>继承了&lt;code>AbstractList&lt;/code>，因此&lt;code>LinkedList&lt;/code>也继承了&lt;code>protected transient int modCount&lt;/code>变量，具体作用与&lt;code>ArayList&lt;/code>中一样，不再赘述。&lt;/p>
&lt;h2 id="构造方法">构造方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#06b6ef">LinkedList&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认构造方法，实现为空方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#06b6ef">LinkedList&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Collection&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>addAll()&lt;/code>方法将参数c中的所有元素增加到当前实例中，完成构造。&lt;/p>
&lt;h2 id="内部类node">内部类Node&lt;/h2>
&lt;h3 id="定义">定义&lt;/h3>
&lt;p>在&lt;code>LinkedList&lt;/code>中，使用&lt;code>Node&lt;/code>内部类存储List的每个元素，其结构比较简单:&lt;/p>
&lt;ul>
&lt;li>&lt;code>item&lt;/code>存储具体的List元素引用&lt;/li>
&lt;li>&lt;code>next&lt;/code>和&lt;code>prev&lt;/code>分别存储后一个和上一个元素的引用，由此构成链表。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">Node&lt;/span>&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E item&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> next&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> prev&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">(&lt;/span>Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> prev&lt;span style="color:#5bc4bf">,&lt;/span> E element&lt;span style="color:#5bc4bf">,&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> next&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">item&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> element&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> next&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">prev&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> prev&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="维护链表的基础方法">维护链表的基础方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 将元素插入到链表头部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * prev=LinkedList.next, next=null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 然后更新first，原来first的prev引用更新为新元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">linkFirst&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 将元素插入到链表尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * prev=null, next=LinkedList.first
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 然后更新last，原来last的next引用更新为新元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">linkLast&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 插入到指定元素前面
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 设置新元素的前后引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 然后对应修改succ的前一项为新元素，以及原来succ的前一项的后者为新元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 如果succ原来的前一项为null，那么新的LinkedList.first就是新元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 我觉得可以直接进来就判断nullsucc原来的前一项时调用linkFirst()进行处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">linkBefore&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">,&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> succ&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 将链表头部元素从链表中移除并返回
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 主要任务是将LinkedList.first指向原来first的next所引用的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 同时将原来first的item以及next设为null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * item设为null是为了原来first元素的GC回收，而next设为null是方便新的first在未来被回收
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 最后size--，modCount++，维护边界条件并返回
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> E &lt;span style="color:#06b6ef">unlinkFirst&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> f&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 类似unlinkLast()，将链表尾部元素从链表中移除并返回，不再赘述
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> E &lt;span style="color:#06b6ef">unlinkLast&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> l&lt;span style="color:#5bc4bf">)&lt;/span>&lt;span style="color:#ef6155">；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 将任一位置的元素从链表中移除并返回
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * 代码实现上类似于unlinkFirst()与unlinkLast()的结合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>E &lt;span style="color:#06b6ef">unlink&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> x&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常规方法">常规方法&lt;/h2>
&lt;h3 id="维护头部尾部的方法">维护头部尾部的方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//first为空则抛NoSuchElementException异常，否则返回first.item
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">getFirst&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//last为空则抛NoSuchElementException异常，否则返回last.item
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">getLast&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//first为空则抛异常，否则调用unlinkFirst()删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">removeFirst&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//last为空则抛异常，否则调用unlinkLast()删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">removeLast&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//调用linkFirst()进行处理，允许e为null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">addFirst&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//调用linkLast()进行处理，允许e为null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">addLast&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="接口常规增删改查方法">接口常规增删改查方法&lt;/h3>
&lt;h4 id="增">增&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">add&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span> &lt;span style="color:#776e71">//调用linkLast()进行处理，并返回true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">add&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> E element&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指定下标插入元素的方法&lt;code>add()&lt;/code>先对&lt;code>index&lt;/code>进行下标越界检查，然后如果&lt;code>index==size&lt;/code>，即插入到List最后面，那么直接调用&lt;code>linkLast()&lt;/code>执行插入就可以；否则调用&lt;code>linkBefore()&lt;/code>插入到指定下标的元素前面，即新的元素拥有&lt;code>index&lt;/code>的下标（符合&lt;code>add()&lt;/code>方法对&lt;code>index&lt;/code>参数的定义）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">addAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Collection&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span> &lt;span style="color:#776e71">//调用addAll(size, c)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">addAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> Collection&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>批量增加方法&lt;code>addAll()&lt;/code>将参数&lt;code>c&lt;/code>里面的元素全部逐个加到当前List中。先检查下标是否越界，然后将Collection转为Object数组，若数组长度为0则返回false。index为要插入的第一个元素所在的下标，如果不是size（最后一个元素之后），则需要读取对应插入处原来的元素及其上一个元素。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> pred&lt;span style="color:#5bc4bf">,&lt;/span> succ&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//插入新元素的前后元素引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>index &lt;span style="color:#5bc4bf">==&lt;/span> size&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> succ &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pred &lt;span style="color:#5bc4bf">=&lt;/span> last&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span> &lt;span style="color:#815ba4">else&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> succ &lt;span style="color:#5bc4bf">=&lt;/span> node&lt;span style="color:#5bc4bf">(&lt;/span>index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pred &lt;span style="color:#5bc4bf">=&lt;/span> succ&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">prev&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>随后遍历Object数组，逐个生成&lt;code>Node&lt;/code>对象，并将上一个元素的next指向当前元素。遍历完后，维护插入新元素的前/后元素的后/前引用，如果succ为null则&lt;code>LinkedList.last&lt;/code>赋值为&lt;code>pred&lt;/code>，同时维护&lt;code>size&lt;/code>，更新&lt;code>modCount&lt;/code>。&lt;/p>
&lt;h4 id="删">删&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>删除元素的方法&lt;code>remove()&lt;/code>类似&lt;code>indexOf()&lt;/code>，从&lt;code>first&lt;/code>开始遍历List，逐个元素判断是否与参数&lt;code>o&lt;/code>相同（判断方法与&lt;code>indexOf()&lt;/code>一样），找到后调用&lt;code>unlink()&lt;/code>进行删除并返回true。如果没找到相同的元素则返回false。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法删除指定下标的元素。检查下标没有越界后，调用&lt;code>unlink(node(index))&lt;/code>删除指定元素（其中&lt;code>node()&lt;/code>是查找指定下标的元素，详见 &lt;em>查&lt;/em> 部分）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">clear&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>清空整个List，从&lt;code>first&lt;/code>开始，遍历整个List，把每个&lt;code>Node&lt;/code>的&lt;code>item next prev&lt;/code>都置为null（方便GC），以及&lt;code>LinkedList&lt;/code>的&lt;code>first last&lt;/code>也置为null，&lt;code>size&lt;/code>归零。&lt;/p>
&lt;h4 id="改">改&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">set&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> E element&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将下标为&lt;code>index&lt;/code>的元素设置为&lt;code>element&lt;/code>，并将旧值返回。该方法在检查&lt;code>index&lt;/code>是否越界后，先调用&lt;code>node()&lt;/code>方法查找到指定下标的&lt;code>Node&lt;/code>元素，直接修改&lt;code>Node&lt;/code>实例的&lt;code>item&lt;/code>属性为新值，并返回旧值（而不是新建一个&lt;code>Node&lt;/code>，这样既减少操作，也减少多余的对象，从而减轻GC负担）。&lt;/p>
&lt;h4 id="旧的查找方法">旧的查找方法&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">contains&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>方法&lt;code>contains()&lt;/code>判断当前List是否包含指定元素，返回&lt;code>indexOf(o) != -1&lt;/code>。&lt;br>
方法&lt;code>indexOf()&lt;/code>从&lt;code>first&lt;/code>开始通过&lt;code>next&lt;/code>引用遍历List，逐个元素判断是否与参数&lt;code>o&lt;/code>相同（o为null则用&lt;code>item==null&lt;/code>进行判断，o非null则调用&lt;code>o.equals(item)&lt;/code>进行判断），与ArrayList的实现类似。&lt;br>
方法&lt;code>lastIndexOf()&lt;/code>的实现与&lt;code>indexOf()&lt;/code>类似，只是查找的起点改成&lt;code>last&lt;/code>，且遍历的方向相反。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">size&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span> &lt;span style="color:#776e71">//返回size属性
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">node&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者&lt;code>node()&lt;/code>方法是通过遍历从链表中查找到指定下标的元素，其中有个优化，如果查找的下标大于&lt;code>size&lt;/code>的一半则从&lt;code>last&lt;/code>引用开始找，否则从&lt;code>first&lt;/code>引用开始找。&lt;br>
后者&lt;code>get()&lt;/code>方法在检查&lt;code>index&lt;/code>参数没有越界后，调用前者进行查找。&lt;/p>
&lt;h4 id="jdk5-开始引入的方法">&lt;em>JDK5&lt;/em> 开始引入的方法&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//获取但不移除该List的头部，first为null时返回null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">peek&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//获取但不移除该List的头部，调用getFirst()，first为null时抛NoSuchElementException异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">element&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//获取并移除该List的头部，first为null时返回null，否则调用unlinkFirst()处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">poll&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//获取并移除该List的头部，调用removeFirst()，first为null时抛NoSuchElementException异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//将指定元素添加到该List的尾部，调用add()方法处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">offer&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="jdk6-开始引入的方法">&lt;em>JDK6&lt;/em> 开始引入的方法&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//在该List的开头插入指定的元素，调用addFirst()方法，后者又调用linkFirst()处理，返回true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">offerFirst&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">// 在该List末尾插入指定的元素，调用addLast()方法，后者又调用linkLast()处理，返回true。实际实现与offer()一致
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">offerLast&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">// 获取但不移除该List的第一个元素；如果该List为空，则返回 null。实现与peek()一样
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">peekFirst&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//获取但不移除该List的最后一个元素；如果该List为空，则返回 null。实现与peek()类似
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">peekLast&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//获取并移除该List的第一个元素；如果该List为空，则返回 null；实现与poll()一样
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">pollFirst&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//获取并移除该List的最后一个元素；如果该List为空，则返回 null；否则调用unlinkLast()进行处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">pollLast&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//将元素推入该List所表示的堆栈。实际调用addFirst()进行处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">push&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//从该List所表示的堆栈处弹出一个元素。实际调用removeFirst()进行处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">pop&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//从该List中移除第一次出现的指定元素（从头部到尾部遍历列表时）。调用remove(o)进行处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">removeFirstOccurrence&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//从该List中移除最后一次出现的指定元素。从last开始向前遍历，找到与o相同的元素;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//再调用unlink()进行删除处理，返回true；遍历完后还找不到对应元素则返回false。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">removeLastOccurrence&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 &lt;em>JDK6&lt;/em> 新增的这些方法实际上是对 &lt;em>JDK5&lt;/em> 新增的方法的扩展，从默认的操作（可能是针对头部或尾部）扩展到对头部和尾部的操作。&lt;/p>
&lt;h3 id="边界检查方法">边界检查方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//是否合法的元素下标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">isElementIndex&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//对迭代器和add()方法而言是否合法下标（允许等于size）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">isPositionIndex&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//生成报错信息字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> String &lt;span style="color:#06b6ef">outOfBoundsMsg&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//检查是否合法的元素下标，不合法则抛IndexOutOfBoundsException异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">checkElementIndex&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//检查对迭代器和add()方法而言是否合法下标，不合法则抛出IndexOutOfBoundsException异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">checkPositionIndex&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="其他方法">其他方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//先调用父类的clone方法复制（其实是Object的本地方法），
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//然后遍历原List，逐个add到克隆后的新List中并返回
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> Object &lt;span style="color:#06b6ef">clone&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//List转数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//根据size新建一个Object数组，遍历List，逐个Node的item属性加到Object数组中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> Object&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">toArray&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//如果a的长度小于size，需要调用java.lang.reflect.Array.newInstance(方法新建一个size长度的T[]数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//然后遍历List，将每个Node元素的item属性复制到数组中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//最后将下标为size的元素置为null（标识数组结束， 数组长度大于size才有这个操作）并返回
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>T&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> T&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">toArray&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>T&lt;span style="color:#5bc4bf">[]&lt;/span> a&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//序列化方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//写入到输出流，先写入size，然后遍历List逐个Node元素的item属性写入输出流
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">writeObject&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>java&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">io&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">ObjectOutputStream&lt;/span> s&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//读取输入流构造List，先读入一个int作为size，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//然后从输入流读取size次，每次读取的对象强转为E类型，并调用linkLast()加入到L链表尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">readObject&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>java&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">io&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">ObjectInputStream&lt;/span> s&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="jdk8-开始引入的方法">&lt;em>JDK8&lt;/em> 开始引入的方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//spliterator：返回一个内部类static final class LLSpliterator&amp;lt;E&amp;gt; implements Spliterator&amp;lt;E&amp;gt; 的实例。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//为了并行遍历数据源中的元素，Stream.isParallel()实现调用。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//关于Spliterator接口在ArrayList源码的笔记里有介绍，在此不再赘述
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//这个实现类在final int getEst()est = LinkedList的size，expectedModCount = LinkedList的modCount
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> Spliterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">spliterator&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="迭代器">迭代器&lt;/h2>
&lt;h3 id="获取迭代器的方法">获取迭代器的方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//检查下标越界后，返回LinkedList的内部类ListItr的实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> ListIterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">listIterator&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//返回的是LinkedList的内部类DescendingIterator的实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> Iterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">descendingIterator&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//返回父类AbstractList的内部类ListItr实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> Iterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> AbstractSequentialList&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">iterator&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="迭代器listitr">迭代器ListItr&lt;/h3>
&lt;p>包含以下成员变量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//next()，previous()，remove()，set()，add()等方法返回的Node元素记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> lastReturned&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//当前游标指向的Node元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> next&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//当前游标的下标值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">int&lt;/span> nextIndex&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//记录应有的modCount，迭代器对链表进行修改后会更新modCount，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//而迭代器以外对链表的操作不会更新这个属性，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//因此外部操作后再进行迭代器的操作会抛出ConcurrentModificationException异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">int&lt;/span> expectedModCount &lt;span style="color:#5bc4bf">=&lt;/span> modCount&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其余&lt;code>ListIterator&lt;/code>接口方法的具体实现在此不表，与&lt;code>ArrayList&lt;/code>的&lt;code>ListItr&lt;/code>的实现类似，只是在一些修改链表的方法里需要对应修改前后元素的引用而已，此外上一个下一个的迭代效率也较高（直接读取Node元素的prev/next引用）。&lt;/p>
&lt;h3 id="迭代器descendingiterator">迭代器DescendingIterator&lt;/h3>
&lt;p>该迭代器是为了实现&lt;code>java.util.Deque&lt;/code>接口的&lt;code>Iterator&amp;lt;E&amp;gt; descendingIterator()&lt;/code>方法。&lt;br>
具体实现还是用前面介绍的&lt;code>LinkedList&lt;/code>的内部类&lt;code>ListItr&lt;/code>。由于是反向的迭代器，因此用私有变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> ListItr itr &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">new&lt;/span> ListItr&lt;span style="color:#5bc4bf">(&lt;/span>size&lt;span style="color:#5bc4bf">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>实现从链表尾部开始迭代。&lt;br>
从尾部迭代到头部的迭代方式（反向迭代）从其他几个方法的具体实现也可以看出来，比较简单，只贴出代码就算了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">hasNext&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> itr&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hasPrevious&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> itr&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">previous&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> itr&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出并没有去重写 &lt;em>JDK8&lt;/em> 的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">default&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">forEachRemaining&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Consumer&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">super&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> action&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>方法。&lt;/p></description></item><item><title>ArrayList源码阅读笔记（JDK8）</title><link>https://leibnizhu.github.io/p/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/</link><pubDate>Tue, 11 Jul 2017 21:48:32 +0800</pubDate><guid>https://leibnizhu.github.io/p/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/</guid><description>&lt;img src="https://leibnizhu.github.io/p/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/city.png" alt="Featured image of post ArrayList源码阅读笔记（JDK8）" />&lt;h1 id="arraylist源码阅读笔记">ArrayList源码阅读笔记&lt;/h1>
&lt;h2 id="继承结构">继承结构&lt;/h2>
&lt;p>&lt;img src="https://leibnizhu.github.io/p/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/ArrayList_UML.png"
width="645"
height="380"
srcset="https://leibnizhu.github.io/p/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/ArrayList_UML_hu5ba80f57c145d5dbfc345eab97b6c938_20550_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/ArrayList_UML_hu5ba80f57c145d5dbfc345eab97b6c938_20550_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="407px"
>&lt;/p>
&lt;h2 id="成员变量">成员变量&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">transient&lt;/span> Object&lt;span style="color:#5bc4bf">[]&lt;/span> elementData&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>存储List数据，用了transient关键字避免被持久化。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">int&lt;/span> size&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>List长度。 &lt;br>
在父类AbstractList中modCount成员变量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#fec418">int&lt;/span> MAX_ARRAY_SIZE &lt;span style="color:#5bc4bf">=&lt;/span> Integer&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">MAX_VALUE&lt;/span> &lt;span style="color:#5bc4bf">-&lt;/span> 8&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有些JVM会在数组保留一些头部信息，为了防止报内存不足Error，在int最大值的基础上预留8个元素。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">protected&lt;/span> &lt;span style="color:#815ba4">transient&lt;/span> &lt;span style="color:#fec418">int&lt;/span> modCount &lt;span style="color:#5bc4bf">=&lt;/span> 0&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表示已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。此字段由iterator和listiterator方法返回的迭代器和列表迭代器实现使用。如果意外更改了此字段中的值，则迭代器（或列表迭代器）将抛出&lt;code>ConcurrentModificationException&lt;/code>来响应next、remove、previous、set或add操作。子类是否使用此字段是可选的。如果子类希望提供快速失败迭代器（和列表迭代器），则它只需在其 add(int,e)和remove(int)方法（以及它所重写的、导致列表结构上修改的任何其他方法）中增加此字段，否则可以忽略此字段。对add(int, e)或remove(int)的单个调用向此字段添加的数量不得超过 1，否则迭代器（和列表迭代器）将抛出虚假的 &lt;code>ConcurrentModificationException&lt;/code>。&lt;/p>
&lt;h2 id="构造方法">构造方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ArrayList&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> initialCapacity&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>initialCapacity大于0的话elementData赋值为对应长度的Object数组；为0的话赋值为EMPTY_ELEMENTDATA（空数组）；负数的情况抛&lt;code>IllegalArgumentException&lt;/code>异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ArrayList&lt;span style="color:#5bc4bf">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认构造方法，elementData赋值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA（空数组）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ArrayList&lt;span style="color:#5bc4bf">(&lt;/span>Collection&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>c先转成数组赋值给elementData，如果长度不为0且数组不为Object数组，则通过&lt;code> Arrays.copyOf()&lt;/code>转换为Object数组；如果长度为0则c先转成数组赋值给elementData，如果长度不为0且数组不为Object数组，则通过重新赋值为EMPTY_ELEMENTDATA（空数组）。&lt;/p>
&lt;h2 id="常规方法">常规方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">trimToSize&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>modCount++后，调用&lt;code>Arrays.copyOf()&lt;/code>将elementData复制到size大小的数组里并赋值给elementData。这样是因为容量常常会大于实际元素的数量。内存紧张时，可以调用该方法删除预留的位置，调整容量为元素实际数量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">ensureCapacity&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> minCapacity&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果数组为空，容量预取0，否则去默认值(DEFAULT_CAPACITY = 10)；若参数大于预设的容量，则使用该参数调用私有方法&lt;code>void ensureCapacityInternal(int minCapacity)&lt;/code>设置数组容量；后者会在当前数组长度不足时调用&lt;code>grow()&lt;/code>进行扩容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">grow&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> minCapacity&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>容量为：当前容量增加一半、及minCapacity中的较大者。如果超过数组最大长度则调用&lt;code>hugeCapacity(int minCapacity)&lt;/code>处理，抛出错误。最后调用&lt;code>Arrays.copyOf()&lt;/code>复制旧数据到新数组并赋值给element。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">size&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span> &lt;span style="color:#776e71">//返回size属性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">isEmpty&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//size是否为0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">contains&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span> &lt;span style="color:#776e71">//调用indexOf()是否大于等于0。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span> &lt;span style="color:#776e71">//下面详解
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>indexOf()查找元素索引，遍历数组逐个对比（如果o为null则直接判断&lt;code>== null&lt;/code>，否则调用&lt;code>o.equals()&lt;/code>进行判断），返回第一次找到的索引值，找不到则返回-1。lastIndexOf()与之类似，只是遍历的方向相反。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> Object &lt;span style="color:#06b6ef">clone&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>Arrays.copyOf()&lt;/code>进行浅拷贝，每个元素只拷贝引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> Object&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">toArray&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>T&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> T&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">toArray&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>T&lt;span style="color:#5bc4bf">[]&lt;/span> a&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者转换为Object数组，调用&lt;code>Arrays.copyOf()&lt;/code>方法。&lt;br>
后者转换为指定类型的数组，返回的数组容量由参数和本数组中较大值确定；如果a参数的长度小于当前size，则调用带Class参数的&lt;code>Arrays.copyOf()&lt;/code>方法进行复制并返回；否则a的长度足够，则调用&lt;code>System.arraycopy()&lt;/code>将elementData复制到a，并将第一个实际没有数据的设为null（a[size]）。&lt;/p>
&lt;h2 id="增删改查方法">增删改查方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>rangeCheck(index);&lt;/code>检查下标是否越界后（越界则抛出&lt;code>IndexOutOfBoundsException&lt;/code>异常），直接从elementData数组根据下标拿值，速度比较快。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">set&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> E element&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>rangeCheck(index);&lt;/code>检查下标是否越界后，读取索引对应的旧值，然后改为新值，并将旧的值返回；注意用到泛型。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">add&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">add&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> E element&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者调用&lt;code>ensureCapacityInternal(size + 1)&lt;/code>确认是否需要扩容后，直接设定数组对应下标的值。&lt;br>
后者先调用&lt;code>rangeCheckForAdd()&lt;/code>确认index参数是否越界，然后同样调用&lt;code>ensureCapacityInternal(size+1)&lt;/code>确认是否需要扩容，将index之后的元素通过&lt;code>System.arraycopy()&lt;/code>方法复制到index+1位置之后，最后将element赋值到下标为index处。&lt;br>
P.S.： System.arraycopy()的参数：src:源数组； srcPos:源数组要复制的起始位置； dest:目的数组； destPos:目的数组放置的起始位置； length:复制的长度。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">addAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Collection&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">addAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> Collection&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者先调用&lt;code>c.toArray()&lt;/code>将参数c转换为数组，然后进行扩容的判断，接着调用&lt;code>System.arraycopy()&lt;/code>将数组的内容复制到elementData后面，并修改size的值，最后c的长度不为0则返回true，为零则返回false。&lt;br>
后者先判断index是否越界及是否需要扩容，然后计算需要移动的元素个数并调用&lt;code>System.arraycopy()&lt;/code>移动index以后的元素，接着调用&lt;code>System.arraycopy()&lt;/code>将c转换的数组复制到index后面，最后修改size的值，根据c的长度返回true/false。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object o&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">protected&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">removeRange&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者按下标进行删除，先检查下标越界后，读取index对应的旧值，计算index下标往后的（需要移动的）元素个数，调用&lt;code>System.arraycopy()&lt;/code>进行移动，随后将原来最后一位改为null（方便GC回收），最后将旧值返回。&lt;br>
中者基本逻辑与前者类似，只是移动数组元素的范围不一样，而且需要遍历将数组尾部多个元素（toIndex - fromIndex个）赋值为null。&lt;br>
后者删除指定对象，遍历数组，找到与o相等的元素（o为null则判断&lt;code>==null&lt;/code>，否则调用&lt;code>o.equals()&lt;/code>判断相等），调用&lt;code>fastRemove()&lt;/code>删除，并返回true；如果找不到对应相等的元素，则返回false。&lt;code>private void fastRemove(int index)&lt;/code>方法的实现与&lt;code>E remove(int index);&lt;/code>基本一直，区别嘛，方法如其名，快就快在不需要进行越界判定，及不需要返回旧值，直接删除。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">clear&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>清空List，遍历数组将每个元素赋值为null，最后将size设为0.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">removeAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Collection&lt;span style="color:#5bc4bf">&amp;lt;?&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span> &lt;span style="color:#776e71">//batchRemove(c, false);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">retainAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Collection&lt;span style="color:#5bc4bf">&amp;lt;?&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span> &lt;span style="color:#776e71">//batchRemove(c, true);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#776e71">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * @param complement true时从数组保留指定集合中元素的值，为false时从数组删除指定集合中元素的值。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> * @return 数组中重复的元素都会被删除(而不是仅删除一次或几次)，有任何删除操作都会返回true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">batchRemove&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Collection&lt;span style="color:#5bc4bf">&amp;lt;?&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> complement&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">final&lt;/span> Object&lt;span style="color:#5bc4bf">[]&lt;/span> elementData &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">elementData&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fec418">int&lt;/span> r &lt;span style="color:#5bc4bf">=&lt;/span> 0&lt;span style="color:#5bc4bf">,&lt;/span> w &lt;span style="color:#5bc4bf">=&lt;/span> 0&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fec418">boolean&lt;/span> modified &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">false&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">try&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//遍历数组，并检查这个集合是否包含对应的值，移动要保留的值到数组前面，w最后值为要保留的元素的数量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">//简单点：若保留，就将相同元素移动到前段；若删除，就将不同元素移动到前段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">for&lt;/span> &lt;span style="color:#5bc4bf">(;&lt;/span> r &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span> size&lt;span style="color:#5bc4bf">;&lt;/span> r&lt;span style="color:#5bc4bf">++)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>c&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">contains&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>elementData&lt;span style="color:#5bc4bf">[&lt;/span>r&lt;span style="color:#5bc4bf">])&lt;/span> &lt;span style="color:#5bc4bf">==&lt;/span> complement&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elementData&lt;span style="color:#5bc4bf">[&lt;/span>w&lt;span style="color:#5bc4bf">++]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> elementData&lt;span style="color:#5bc4bf">[&lt;/span>r&lt;span style="color:#5bc4bf">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">finally&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//确保异常抛出前的部分可以完成期望的操作，而未被遍历的部分会被接到后面
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">//r!=size表示可能出错了：c.contains(elementData[r])抛出异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>r &lt;span style="color:#5bc4bf">!=&lt;/span> size&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">arraycopy&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>elementData&lt;span style="color:#5bc4bf">,&lt;/span> r&lt;span style="color:#5bc4bf">,&lt;/span>elementData&lt;span style="color:#5bc4bf">,&lt;/span> w&lt;span style="color:#5bc4bf">,&lt;/span>size &lt;span style="color:#5bc4bf">-&lt;/span> r&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> w &lt;span style="color:#5bc4bf">+=&lt;/span> size &lt;span style="color:#5bc4bf">-&lt;/span> r&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//如果w==size：表示全部元素都保留了，所以也就没有删除操作发生，所以会返回false；反之，返回true，并更改数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">//而w!=size的时候，即使try块抛出异常，也能正确处理异常抛出前的操作，因为w始终为要保留的前段部分的长度，数组也不会因此乱序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>w &lt;span style="color:#5bc4bf">!=&lt;/span> size&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">for&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> i &lt;span style="color:#5bc4bf">=&lt;/span> w&lt;span style="color:#5bc4bf">;&lt;/span> i &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span> size&lt;span style="color:#5bc4bf">;&lt;/span> i&lt;span style="color:#5bc4bf">++)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elementData&lt;span style="color:#5bc4bf">[&lt;/span>i&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modCount &lt;span style="color:#5bc4bf">+=&lt;/span> size &lt;span style="color:#5bc4bf">-&lt;/span> w&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//改变的次数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> size &lt;span style="color:#5bc4bf">=&lt;/span> w&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//新的大小为保留的元素的个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> modified &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">true&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> modified&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前两个方法调用后面的&lt;code>batchRemove()&lt;/code>方法（具体看上面的注释），第一个方法删除c里面的元素，第二个方法保留c里面的元素，有任何删除操作都会返回true，返回false表示没有删除任一元素。不难看出&lt;code>batchRemove()&lt;/code>方法的时间复杂度是&lt;code>O(n^2)&lt;/code>，大致逻辑是遍历数组，根据complement条件判断要保留的元素依次复制到数组的前面，w保存要保留的最大下标，如果期间发生异常则将未处理的元素都保留，遍历后将w之后的元素设置为null等待GC。&lt;/p>
&lt;h2 id="io方法">IO方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">writeObject&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>java&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">io&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">ObjectOutputStream&lt;/span> s&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">readObject&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>java&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">io&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">ObjectInputStream&lt;/span> s&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者将List序列化到输出流，先写入size，再逐个元素写入，写入过程数组被更改会抛出ConcurrentModificationException异常。&lt;br>
后者读取输入流反序列化到List，先从输入流读取一个int，判断这个int作为size的话是否需要扩容，然后从输入流中读取Object从下标0开始逐个写入到elementData数组中（就是说读取的数量小于原来size的话，读取最后的下标之后的元素不会变动）。&lt;/p>
&lt;h2 id="迭代器方法">迭代器方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> ListIterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">listIterator&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span> &lt;span style="color:#776e71">//new ListItr(index);开始位置为指定参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> ListIterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">listIterator&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span> &lt;span style="color:#776e71">//return new ListItr(0);开始位置为0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> Iterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">iterator&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span> &lt;span style="color:#776e71">//return new Itr();
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>迭代器方法分别返回ListItr和Itr内部类的实例，而ListItr继承了Itr。&lt;/p>
&lt;h3 id="迭代器类itr">迭代器类Itr&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">Itr&lt;/span> &lt;span style="color:#815ba4">implements&lt;/span> Iterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#5bc4bf">{}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="成员变量-1">成员变量&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> cursor&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//游标，下一个元素的索引，默认初始化为0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#fec418">int&lt;/span> lastRet &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#5bc4bf">-&lt;/span>1&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//上次返回的元素的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#fec418">int&lt;/span> expectedModCount &lt;span style="color:#5bc4bf">=&lt;/span> modCount&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//迭代过程不运行修改数组，否则就抛出异常
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="iterator接口方法">Iterator接口方法&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">hasNext&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回cursor != size;，如果游标到了size那也就是没有下一个了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先调用&lt;code>checkForComodification()&lt;/code>检查是否被修改过，然后判断如果游标已经越界则抛出&lt;code>NoSuchElementException&lt;/code>异常，否则lastRet改为游标值，游标前进，返回原来游标指向的元素。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>lastRet &amp;lt; 0时抛&lt;code>IllegalStateException&lt;/code>异常，然后检查是否被修改过，随后调用&lt;code>ArrayList.remove(int index)&lt;/code>移除元素，游标后退，lastRet重设为-1，expectedModCount赋值为新的modCount。&lt;br>
基本上ArrayList采用size来维护自已状态，而Iterator采用cursor维护自已状态。当size出现变化时，cursor并不一定能够得到同步，除非这种变化是Iterator主动导致的，比如调用remove()方法导致ArrayList列表发生变化时，迭代器会更新cursor来同步这一变化，但其他方式导致的ArrayList变化Iterator无法感知，ArrayList也不会主动通知Iterator们。Iterator为了防止状态不一致可能引发的后果经常做checkForComodification检查，以防有变。如果有变，则以异常抛出。&lt;br>
所以在循环里删除元素的话要用迭代器的remove()方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">forEachRemaining&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Consumer&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">super&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> consumer&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JDK8开始有的方法，遍历数组，分别传入调用&lt;code>consumer.accept((E) elementData[i++]);&lt;/code>，即对每个元素执行同一方法。&lt;/p>
&lt;h4 id="其他方法">其他方法&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">checkForComodification&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>modCount != expectedModCount则抛出ConcurrentModificationException异常。&lt;/p>
&lt;h3 id="迭代器类listitr">迭代器类ListItr&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">ListItr&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> Itr &lt;span style="color:#815ba4">implements&lt;/span> ListIterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#5bc4bf">{}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="构造器">构造器&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ListItr&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将游标设置为index。&lt;/p>
&lt;h4 id="接口方法">接口方法&lt;/h4>
&lt;p>接口&lt;code> Iterator&lt;/code>的方法在Itr中实现了，该类实现了&lt;code>ListIterator&lt;/code>接口中其他的方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">hasPrevious&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> cursor &lt;span style="color:#5bc4bf">!=&lt;/span> 0&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//根据游标判断是否有前一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">nextIndex&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> cursor&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//游标即为下一个要迭代到的元素的下标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">previousIndex&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> cursor &lt;span style="color:#5bc4bf">-&lt;/span> 1&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//游标减一即上一个元素（当前已迭代的）的下标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这三个方法比较简单就不具体讲了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">previous&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回上一个元素同时游标回退，与&lt;code>next()&lt;/code>方法类似，先检查是否被修改以及是否下标越界，然后lastRet和游标减一，返回索引减一之后对应的元素。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">set&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用指定元素替换 next 或 previous 返回的最后一个元素。先判定lastRet不小于0，否则抛出IllegalStateException异常。lastRet初始化为-1，之后只有调用ListIterator.add(E e)和remove()之后lastRet会恢复到-1。因为修改的是下标=lastRet的元素，所以不允许为-1，也就是说，只有在最后一次调用 next 或 previous 后既没有调用 ListIterator.remove 也没有调用 ListIterator.add 时才可以进行该调用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">add&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将指定的元素插入列表。在当前游标处调用&lt;code>List.add()&lt;/code>方法插入一个元素e，然后游标前进，lastRet恢复-1，同时更新expectedModCount。&lt;br>
新元素被插入到游标前：不影响对 next 的后续调用，并且对 previous 的后续调用会返回此新元素。&lt;/p>
&lt;h2 id="sublist方法与sublist内部类">subList()方法与SubList内部类&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//检查下标越界后，返回SubList的实例（用fromIndex、toIndex参数构造）作为子列表。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> List&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">subList&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//用于subList()方法的下标越界检查方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">subListRangeCheck&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> size&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//SubList类
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">SubList&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> AbstractList&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#815ba4">implements&lt;/span> RandomAccess
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//注意在AbstractList.java源文件里也有一个SubList，然而并不是AbstractList的内部类，AbstractList.subList()方法会返回这个SubList的实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">SubList&lt;/span>&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> AbstractList&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#5bc4bf">{}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SubList继承AbstractList抽象类，是List的实现类，主要用于返回ArrayList的视图，这个视图是原ArrayList对象中的一部分，确实是一部分，直接将原ArrayList对象引用到新的子视图的ArrayList，对子视图进行改变，原ArrayList对象也会随之改变。&lt;/p>
&lt;h3 id="成员变量-2">成员变量&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> AbstractList&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> parent&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//保存母ArrayList的引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#fec418">int&lt;/span> parentOffset&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//subList方法的fromIndex参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//subList方法的fromIndex参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#fec418">int&lt;/span> size&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//subList方法的参数相减：toIndex - fromIndex
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时，modCount赋值为母ArrayList的modCount。&lt;/p>
&lt;h3 id="接口方法-1">接口方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">set&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">size&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">add&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> E e&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> E &lt;span style="color:#06b6ef">remove&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">protected&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">removeRange&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">addAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Collection&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">addAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> Collection&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> Spliterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">spliterator&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些方法的实现与ArrayList的实现都大同小异，差异在与下标多了偏移量parentOffset，而且最后调用parent（ArrayList）的同名方法进行处理。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> List&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">subList&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回自己的类（SubList），构造方法的offset参数为offset（母ArrayList的subList方法的fromIndex参数）。&lt;/p>
&lt;h3 id="迭代器方法-1">迭代器方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> Iterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">iterator&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> ListIterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">listIterator&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者返回的是AbstractList的内部类ListItr，实现了ListIterator接口，具体不表。&lt;br>
后者返回ListIterator接口的一个匿名内部类，与ArrayList的ListItr的区别也是在于对ArrayList的elementData数组进行操作时，使用的下标加上offset（母ArrayList的subList方法的fromIndex参数）。&lt;/p>
&lt;h3 id="其他方法检查方法">其他方法（检查方法）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">rangeCheck&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">rangeCheckForAdd&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> String &lt;span style="color:#06b6ef">outOfBoundsMsg&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">checkForComodification&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查下标越界、并行修改等，与ArrayList类似，具体不表。&lt;/p>
&lt;h2 id="jdk8新增方法">JDK8新增方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//forEach：for循环遍历elementData，每个元素分别调用action.accept(elementData[i])方法进行处理，如果处理过程中ArrayList被并行修改了，那么抛出ConcurrentModificationException异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">forEach&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Consumer&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">super&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> action&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//spliterator：返回一个内部类 static final class ArrayListSpliterator&amp;lt;E&amp;gt; implements Spliterator&amp;lt;E&amp;gt;的实例。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//为了并行遍历数据源中的元素，Stream.isParallel()实现调用。下面专门一小节讲Spliterator接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//这个实现类在private int getFence()方法里面初始化了fence = ArrayList的size，expectedModCount = ArrayList的modCount
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> Spliterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">spliterator&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//删除指定条件的元素。先遍历数组，将符合条件（filter.test(element) == true）的元素的下标设置到一个BitSet的对应下标元素中，即这个BitSet哪一位为true，对应下标在ArrayList的元素就符合filter规则，并使用removeCount记录满足规则的个数。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//遍历后如果有满足filter规则的元素，则遍历数组，将被删除的元素后面的元素往前移，最后将末尾无效数据设为null。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//若有删除的元素则返回true，否则返回false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">removeIf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Predicate&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">super&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> filter&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//与forEach()类似，检查operator不为空，然后遍历数组，每个元素调用operator.apply((E) elementData[i])进行处理，最后判断是否发生了并发修改，并增加modCount。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">replaceAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>UnaryOperator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> operator&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//调用Arrays.sort(T[] a, int fromIndex, int toIndex, Comparator&amp;lt;? super T&amp;gt; c)进行排序，最后判断是否发生了并发修改，并增加modCount。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">sort&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Comparator&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">super&lt;/span> E&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="spliterator接口提供的方法">Spliterator接口提供的方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">tryAdvance&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Consumer&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">super&lt;/span> T&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> action&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Spliterator&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>T&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">trySplit&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">long&lt;/span> &lt;span style="color:#06b6ef">estimateSize&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">characteristics&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>tryAdvance()就是顺序处理每个元素，类似Iterator，如果还有元素要处理，则返回true，否则返回false&lt;/li>
&lt;li>trySplit()，这就是为Spliterator专门设计的方法，区分与普通的Iterator，该方法会把当前元素划分一部分出去创建一个新的Spliterator作为返回，两个Spliterator变会并行执行，如果元素个数小到无法划分则返回null&lt;/li>
&lt;li>estimateSize()，该方法用于估算还剩下多少个元素需要遍历&lt;/li>
&lt;li>characteristics()，其实就是表示该Spliterator有哪些特性，用于可以更好控制和优化Spliterator的使用。&lt;/li>
&lt;/ol></description></item><item><title>String源码阅读笔记（JDK8）</title><link>https://leibnizhu.github.io/p/String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/</link><pubDate>Sun, 09 Jul 2017 20:54:16 +0800</pubDate><guid>https://leibnizhu.github.io/p/String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/</guid><description>&lt;img src="https://leibnizhu.github.io/p/String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/cup.png" alt="Featured image of post String源码阅读笔记（JDK8）" />&lt;h1 id="string源码阅读笔记">String源码阅读笔记&lt;/h1>
&lt;h2 id="成员变量">成员变量&lt;/h2>
&lt;p>value，存放String数据，不可变。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#fec418">char&lt;/span> value&lt;span style="color:#5bc4bf">[];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hash，存放String的哈希值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">int&lt;/span> hash&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">// Default to 0
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="构造器部分">构造器部分&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>String original&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将参数的value和hash复制给当前对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> value&lt;span style="color:#5bc4bf">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>Arrays.copyOf()&lt;/code>复制到value属性中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> value&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> count&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先判断offset和count与value的长度对比是否可用，然后调用&lt;code>Arrays.copyOfRange()&lt;/code>复制到value属性中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> codePoints&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> count&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>类似上面，判断完之后，再遍历codePoints排除非法int，最后遍历codePoints强转char[]，赋值给value属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> length&lt;span style="color:#5bc4bf">,&lt;/span> String charsetName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查参数没有越界后，调用&lt;code>StringCoding.decode()&lt;/code>生成char[]赋值给value属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> length&lt;span style="color:#5bc4bf">,&lt;/span> Charset charset&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>类似上面，只是代表编码的参数改了类型。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> String charsetName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> Charset charset&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> length&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别调用上面两个构造方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>StringBuffer buffer&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>StringBuilder builder&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>Arrays.copyOf()&lt;/code>利用参数的value和length生成char[]赋值给value属性。两者区别在于前者多了synchronized修饰。&lt;br>
而关于&lt;code>StringCoding.decode()&lt;/code>，从源码可以看出来，默认的情况下会调用Charset.defaultCharset()获取默认编码，默认情况下获取到&lt;code>UTF-8&lt;/code>编码，如果获取失败或者获取到的并不支持的话则使用&lt;code>ISO-8859-1&lt;/code>编码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/* StringCoding类 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">decode&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> ba&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> off&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> len&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String csn &lt;span style="color:#5bc4bf">=&lt;/span> Charset&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">defaultCharset&lt;/span>&lt;span style="color:#5bc4bf">().&lt;/span>&lt;span style="color:#06b6ef">name&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">try&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// use charset name decode() variant which provides caching.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">return&lt;/span> decode&lt;span style="color:#5bc4bf">(&lt;/span>csn&lt;span style="color:#5bc4bf">,&lt;/span> ba&lt;span style="color:#5bc4bf">,&lt;/span> off&lt;span style="color:#5bc4bf">,&lt;/span> len&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span> &lt;span style="color:#815ba4">catch&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>UnsupportedEncodingException x&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> warnUnsupportedCharset&lt;span style="color:#5bc4bf">(&lt;/span>csn&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">try&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> decode&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;ISO-8859-1&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span> ba&lt;span style="color:#5bc4bf">,&lt;/span> off&lt;span style="color:#5bc4bf">,&lt;/span> len&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span> &lt;span style="color:#815ba4">catch&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>UnsupportedEncodingException x&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// If this code is hit during VM initialization, MessageUtils is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">// the only way we will be able to get any kind of error message.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> MessageUtils&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">err&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;ISO-8859-1 charset not available: &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">+&lt;/span> x&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">toString&lt;/span>&lt;span style="color:#5bc4bf">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// If we can not find ISO-8859-1 (a required encoding) then things
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">// are seriously wrong with the installation.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">exit&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>1&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/* Charset类 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> Charset &lt;span style="color:#06b6ef">defaultCharset&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>defaultCharset &lt;span style="color:#5bc4bf">==&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">synchronized&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>Charset&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">class&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String csn &lt;span style="color:#5bc4bf">=&lt;/span> AccessController&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">doPrivileged&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">new&lt;/span> GetPropertyAction&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;file.encoding&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Charset cs &lt;span style="color:#5bc4bf">=&lt;/span> lookup&lt;span style="color:#5bc4bf">(&lt;/span>csn&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>cs &lt;span style="color:#5bc4bf">!=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultCharset &lt;span style="color:#5bc4bf">=&lt;/span> cs&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultCharset &lt;span style="color:#5bc4bf">=&lt;/span> forName&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;UTF-8&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> defaultCharset&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有值得注意的时，String还提供了一个保护类型的构造方法&lt;code>String(char[] value, boolean share)&lt;/code>，与&lt;code>String(char[] value)&lt;/code>区别在于多了一个没用的参数，以便重载构造方法，而且实现时直接将参数的数组赋值给当前String对象的value属性，而不是复制数组，也就是说这个方法构造出来的String和参数传过来的char[]共享同一个数组，并不安全，这样的设计是出于性能和节约内存的考虑，因此这个方法是包私有的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> value&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> share&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// assert share : &amp;#34;unshared not supported&amp;#34;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">value&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> value&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="其他方法">其他方法&lt;/h2>
&lt;h3 id="静态工厂方法">静态工厂方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object obj&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Object的toString()方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> data&lt;span style="color:#5bc4bf">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">copyValueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> data&lt;span style="color:#5bc4bf">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用String(char value[])构造器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> data&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> count&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">copyValueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> data&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> count&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用String(char value[], int offset, int count)构造器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">boolean&lt;/span> b&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回&amp;quot;true&amp;quot;或&amp;quot;false&amp;quot;。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用String(char[] value, true)构造器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> i&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">long&lt;/span> l&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">float&lt;/span> f&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">double&lt;/span> d&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用参数对应包装类的toString()方法。&lt;/p>
&lt;h3 id="intern方法">intern()方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">native&lt;/span> String &lt;span style="color:#06b6ef">intern&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法返回一个字符串对象的内部化引用。 众所周知：String类维护一个初始为空的字符串的对象池，当intern方法被调用时，如果对象池中已经包含这一个相等的字符串对象则返回对象池中的实例，否则添加字符串到对象池并返回该字符串的引用。&lt;/p>
&lt;h3 id="对的重载">对“+”的重载&lt;/h3>
&lt;p>String对“+”的支持其实就是使用了StringBuilder以及他的append()、toString()le两个方法。&lt;/p>
&lt;h3 id="常规方法">常规方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">isEmpty&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>判断length是否为0。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">char&lt;/span> &lt;span style="color:#06b6ef">charAt&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>判断越界，然后直接从value数组取值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">codePointAt&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">codePointBefore&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">codePointCount&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> beginIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> endIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">offsetByCodePoints&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> codePointOffset&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>判断越界然后调用Character对应静态方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">byte&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">getBytes&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String charsetName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">byte&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">getBytes&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Charset charset&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">byte&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">getBytes&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用StringCoding.encode()编码返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">substring&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> beginIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">substring&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> beginIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> endIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CharSequence &lt;span style="color:#06b6ef">subSequence&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> beginIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> endIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用String的构造方法&lt;code>String(char value[], int offset, int count)&lt;/code>，将会将原来的char[]中的值逐一复制到新的String中，两个数组并不是共享的，虽然这样做损失一些性能，但是有效地避免了内存泄露。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">concat&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先将原来数据用&lt;code>Arrays.copyOf()&lt;/code>复制到一个char数组中，然后调用&lt;code>getChars()&lt;/code>将str的值复制到char数组后面，最后调用共享char[]的构造方法将char数组构造成新的String对象并返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">matches&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Pattern.matches()方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">contains&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>CharSequence s&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用indexOf()进行判断，只要返回索引大于-1即包含。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">split&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> limit&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">split&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>后者调用前者；如果regex长度为1而且不包含&lt;code>&amp;quot;.$|()[{^?*+\\&amp;quot;&lt;/code>，或者regex长度为2而且以&lt;code>&amp;quot;\\&amp;quot;&lt;/code>开头且第二个字符非数字字母（总而言之分割的正则其实只有一个字符），则创建一个List，遍历value，读取匹配到regex的时候，切取分隔符前面的子字符串，放入List中，最后一段也放入List，最后根据limit创建一个子List转换为String[]并返回；否则调用&lt;code>Pattern.compile(regex).split()&lt;/code>进行计算并返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">join&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>CharSequence delimiter&lt;span style="color:#5bc4bf">,&lt;/span> CharSequence&lt;span style="color:#5bc4bf">...&lt;/span> elements&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">join&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>CharSequence delimiter&lt;span style="color:#5bc4bf">,&lt;/span> Iterable&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> CharSequence&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> elements&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用StringJoiner的add()和toString()方法进行拼接。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">toLowerCase&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Locale locale&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">toLowerCase&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">toUpperCase&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Locale locale&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">toUpperCase&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>涉及到多语言的实现，实现起来比较复杂，没仔细看。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">trim&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别从头和尾开始遍历找到首次不为空字符的位置，取子字符串返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">toCharArray&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个同样长度的char数组，调用&lt;code>System.arraycopy()&lt;/code>复制并返回，避免安全性问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">format&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String format&lt;span style="color:#5bc4bf">,&lt;/span> Object&lt;span style="color:#5bc4bf">...&lt;/span> args&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">format&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Locale l&lt;span style="color:#5bc4bf">,&lt;/span> String format&lt;span style="color:#5bc4bf">,&lt;/span> Object&lt;span style="color:#5bc4bf">...&lt;/span> args&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Formatter的&lt;code>format()&lt;/code>方法进行计算并返回。&lt;/p>
&lt;h3 id="替代方法">替代方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">replace&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> oldChar&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">char&lt;/span> newChar&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果新旧字符一样则直接返回this好了，否则先遍历，找到第一次出现oldChar的下标，如果没找到也是返回this，找到则将该下标之前的值循环复制到新数组，此下标之后的值复制到新数组的时候先判断是否oldChar，是的话复制newChar到新数组；最后用新数组构造一个String并返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">replaceFirst&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">,&lt;/span> String replacement&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Pattern.matcher()找到匹配之后，再调用Matcher.replaceFirst()来替换首次出现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">replaceAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">,&lt;/span> String replacement&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Pattern.matcher()找到匹配之后，再调用Matcher.replaceAll()来替换全部。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">replace&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>CharSequence target&lt;span style="color:#5bc4bf">,&lt;/span> CharSequence replacement&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样调用Pattern.matcher().replaceAll()，支持单个字符。&lt;/p>
&lt;h3 id="比较方法">比较方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">equals&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object anObject&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先判断是否this，再判断是否String对象，再判断长度是否相等，最后逐个char进行对比。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">contentEquals&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>StringBuffer sb&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>contentEquals(CharSequence cs)&lt;/code>，该方法判断如果是StringBuffer则加同步去执行&lt;code>nonSyncContentEquals(AbstractStringBuilder sb)&lt;/code>，否则（StringBuilder的情况）不加同步直接执行。 而&lt;code>nonSyncContentEquals(AbstractStringBuilder sb)&lt;/code>中具体的比较流程与equals基本一致。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">equalsIgnoreCase&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String anotherString&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先后判断是否this、是否null、长度是否相同，然后调用&lt;code>boolean regionMatches()&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">regionMatches&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">boolean&lt;/span> ignoreCase&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toffset&lt;span style="color:#5bc4bf">,&lt;/span> String other&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> ooffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> len&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比较this和other是否相等，先判断越界，再逐个字符比较，相同则继续，不同则根据ignoreCase参数，如果true则先将比较双方转成大写进行相等判断，还不相等则转成小写（针对格鲁吉亚语）进行判断。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">startsWith&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String prefix&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toffset&lt;span style="color:#5bc4bf">),&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">startsWith&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String prefix&lt;span style="color:#5bc4bf">)&lt;/span>&lt;span style="color:#ef6155">```&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>后者调用前者&lt;span style="color:#ef6155">，&lt;/span>从指定偏移量开始&lt;span style="color:#ef6155">，&lt;/span>逐个字符进行判断是否相等&lt;span style="color:#ef6155">，&lt;/span>判断次数为prefix的长度&lt;span style="color:#ef6155">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ef6155">```&lt;/span>java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">endsWith&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String suffix&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>startsWith(suffix, value.length - suffix.value.length)&lt;/code>，判断this的后面N（suffix的长度）个字符是否与suffix相等。&lt;/p>
&lt;h3 id="哈希方法">哈希方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">hashCode&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hash属性初始化为0，如果调用hashCode()的时候发现hash为0则开始计算哈希值（懒加载）；由于String不可变，则hash计算一次即可。哈希算法核心为&lt;code>h = 31 * h + val[i];&lt;/code>，遍历所有字符，循环地加上乘以31的哈希值作为新的哈希值，相当于&lt;code>val[0]*31^(n-1) + val[1]*31^(n-2) + ... + val[n-1]&lt;/code>；而选用31，可能时出于&lt;code>i*31== (i&amp;lt;&amp;lt;5)-1&lt;/code>的考虑。&lt;/p>
&lt;h3 id="查找方法">查找方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者调用后者（fromIndex=0），先判断越界，然后有两种情况就是ch对应单字节和双字节，单字节则直接从fromIndex开始遍历对比查找，双字节则调用&lt;code>int indexOfSupplementary(int ch, int fromIndex)&lt;/code>遍历查找的时候同时判断两个字节。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOfSupplementary&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与indexOf()系列类似，只是遍历查找的起点和方向不同。&lt;br>
 &lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> source&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceCount&lt;span style="color:#5bc4bf">,&lt;/span> String target&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> source&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceCount&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> target&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> targetOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> targetCount&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前三者调用最后一个方法。处理完越界和特殊情况后，开始遍历，遍历过程中每次先找到this中出现target的第一个字符（减少判断），找到后开始从当前下标开始，this的值与target的值逐个比较，判断到不相等的值或者到target的结尾则退出判断，然后如果退出判断时的下标等于开始判断下标+target长度，那么就是找到了，返回开始判断的下标，否则继续外面的循环。并没有用KMP算法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> source&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceCount&lt;span style="color:#5bc4bf">,&lt;/span> String target&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> source&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceCount&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> target&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> targetOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> targetCount&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与indexOf()系列类似，只是查找的方向以及起始位置不一样了。&lt;/p></description></item><item><title>HashMap源码阅读笔记</title><link>https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 24 Dec 2016 16:48:04 +0800</pubDate><guid>https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid><description>&lt;h1 id="put方法">put方法：&lt;/h1>
&lt;p>put方法调用私有方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>putVal&lt;span style="color:#5bc4bf">(&lt;/span>hash&lt;span style="color:#5bc4bf">(&lt;/span>key&lt;span style="color:#5bc4bf">),&lt;/span>key&lt;span style="color:#5bc4bf">,&lt;/span>value&lt;span style="color:#5bc4bf">,&lt;/span>&lt;span style="color:#815ba4">false&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>&lt;span style="color:#815ba4">true&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="先去计算hash">先去计算hash。&lt;/h2>
&lt;p>key非空的时候返回：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>h&lt;span style="color:#5bc4bf">=&lt;/span>key&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hashCode&lt;/span>&lt;span style="color:#5bc4bf">())^(&lt;/span>h&lt;span style="color:#5bc4bf">&amp;gt;&amp;gt;&amp;gt;&lt;/span>16&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>即高16位不变，低16位与高16位做异或运算，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;amp;位操作，而非%求余)：(n - 1) &amp;amp; hash 。设计者认为这方法很容易发生碰撞。在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。因此，综合考虑了速度、作用、质量，把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。&lt;/p>
&lt;h2 id="然后进入putval">然后进入putVal()。&lt;/h2>
&lt;p>首先判断table是否为空（null或长度为0），为空的话进行resize()。&lt;/p>
&lt;h2 id="resize">resize()&lt;/h2>
&lt;p>如果原来table大小已经超过上限，则不resize，直接返回原来table；
原来table大小不为0且未超上限则容量增倍，threshold（扩容阈值）也增倍；
原来table大小为0，则大小设为DEFAULT_INITIAL_CAPACITY=16，threshold设为DEFAULT_LOAD_FACTOR*DEFAULT_INITIAL_CAPACITY=12。
然后按新的table大小，new一个Node数组。此时如果旧的table不为空，则需要进行原有数据的转移。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>oldTab&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">for&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>intj&lt;span style="color:#5bc4bf">=&lt;/span>0&lt;span style="color:#5bc4bf">;&lt;/span>j&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>oldCap&lt;span style="color:#5bc4bf">;++&lt;/span>j&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">=&lt;/span>oldTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">])!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> oldTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">]=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hash&lt;/span>&lt;span style="color:#5bc4bf">&amp;amp;(&lt;/span>newCap&lt;span style="color:#5bc4bf">-&lt;/span>1&lt;span style="color:#5bc4bf">)]=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elseif&lt;span style="color:#5bc4bf">(&lt;/span>e &lt;span style="color:#815ba4">instanceof&lt;/span> TreeNode&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">((&lt;/span>TreeNode&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;)&lt;/span>e&lt;span style="color:#5bc4bf">).&lt;/span>&lt;span style="color:#06b6ef">split&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>newTab&lt;span style="color:#5bc4bf">,&lt;/span>j&lt;span style="color:#5bc4bf">,&lt;/span>oldCap&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">else&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span>&lt;span style="color:#776e71">//preserveorder
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>loHead&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>loTail&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>hiHead&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>hiTail&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>next&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">do&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hash&lt;/span>&lt;span style="color:#5bc4bf">&amp;amp;&lt;/span>oldCap&lt;span style="color:#5bc4bf">)==&lt;/span>0&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>loTail&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loHead&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loTail&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">else&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>hiTail&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiHead&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiTail&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">while&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">=&lt;/span>next&lt;span style="color:#5bc4bf">)!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>loTail&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">]=&lt;/span>loHead&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>hiTail&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">+&lt;/span>oldCap&lt;span style="color:#5bc4bf">]=&lt;/span>hiHead&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>大致意思就是遍历旧表的元素：
1.如果旧表元素的next为空（没有发生冲突而放入链表），则计算hash放进新表对应位置：newTab[旧表元素.hash&amp;amp;(newCap-1)]=旧表元素（newCap为新的table长度）;
2.若旧表元素为TreeNode实例，即该节点使用了红黑树进行存储的（JDK8开始引入），则执行split方法去处理；
3.否则遍历旧表元素的对应链表，重新计算位置。
resize的时候，因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂（oldCap）的位置，例如我们从16扩展为32时，具体的变化如下所示：
&lt;img src="https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1.png"
width="727"
height="67"
srcset="https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1_hu30e718e41d0f537c7be0bcca5730372d_7396_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1_hu30e718e41d0f537c7be0bcca5730372d_7396_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1085"
data-flex-basis="2604px"
>
因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色，0或1)。
因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了（通过&lt;code>(e.hash&amp;amp;oldCap)==0&lt;/code>进行判断），是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：
&lt;img src="https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2.png"
width="621"
height="353"
srcset="https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2_hu9b25c08baa945f3801d9bb9649882515_11884_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2_hu9b25c08baa945f3801d9bb9649882515_11884_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="422px"
>
既省去了重新计算hash值的时间，而且由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。
上面代码中else{//preserveorder之后的部分即完成了上述过程，将一个节点上的链表拆分成用loHead,loTail和hiHead,hiTail
描述的两个链表，分别对应新表中位置不变的节点，和移动oldCap之后的节点。&lt;/p>
&lt;h2 id="新建节点或更新value">新建节点或更新value&lt;/h2>
&lt;p>然后判断当前hash值对应table的节点是否为空，为空的话直接新建节点即可：new Node&amp;lt;&amp;gt;(hash,key,value,null);最后一个参数是next，因为table原节点为空，为链表第一个元素，所以next设为null即可；
如果hash值对应table节点不为空，则判断原节点和当前插入的数据key及value是否都一致，如果一致，证明是同一个节点，无需重新插入；
否则进入table节点的链表，遍历，如果找到与待插入节点一样的节点，则直接退出，否则一直找到链表末端节点还没找到相同的，则增加新节点插入当前数据，如果当前链表长度大于TREEIFY_THRESHOLD-1，还需要进行treeifyBin()操作，将链表转换为红黑树，提高查询效率（O(n)变为O(logn)，JDK8之后引入的优化）。
如果以上操作中找到待插入节点的key在map中已存在，则用新数据覆盖之，最后size++, 判断table尺寸，看是否需要进行resize()。&lt;/p>
&lt;h1 id="get方法">get方法：&lt;/h1>
&lt;p>get时调用&lt;code>getNode(int hash, Object key)&lt;/code>方法。
首先table为null或长度为0或对应hash位置的元素为null均返回null。
否则先判断hash位置上的元素key和get方法的key相同，如果相同则直接返回hash位置的元素；否则判断hash位置节点是否为TreeNode，若是则调用getTreeNode方法进行处理并返回；对于非TreeNode节点，且hash位置节点的key不等于get方法dekey的话，则遍历hash位置节点的链表，直到找到key相同的节点并返回节点的value。&lt;/p></description></item></channel></rss>