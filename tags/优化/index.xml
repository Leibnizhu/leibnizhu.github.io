<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>优化 on Heaven's Door</title><link>https://leibnizhu.github.io/tags/%E4%BC%98%E5%8C%96/</link><description>Recent content in 优化 on Heaven's Door</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 09 Jun 2017 12:43:44 +0800</lastBuildDate><atom:link href="https://leibnizhu.github.io/tags/%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>《深入理解Java虚拟机》 学习笔记(四)——类加载机制与JVM优化</title><link>https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/</link><pubDate>Fri, 09 Jun 2017 12:43:44 +0800</pubDate><guid>https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/</guid><description>&lt;p>&lt;strong>JVM笔记系列索引&lt;/strong>&lt;br>
&lt;a class="link" href="https://leibnizhu.github.io/p/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b8%80JVM%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84/" >《深入理解Java虚拟机》 学习笔记(一)——JVM内存结构&lt;/a>&lt;br>
&lt;a class="link" href="https://leibnizhu.github.io/p/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%ba%8c%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6/" >《深入理解Java虚拟机》 学习笔记(二)——垃圾回收&lt;/a>&lt;br>
&lt;a class="link" href="https://leibnizhu.github.io/p/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b8%89%e7%b1%bb%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84/" >《深入理解Java虚拟机》 学习笔记(三)——类文件结构&lt;/a>&lt;br>
&lt;a class="link" href="https://leibnizhu.github.io/p/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e5%9b%9b%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6%e4%b8%8eJVM%e4%bc%98%e5%8c%96/" >《深入理解Java虚拟机》 学习笔记(四)——类加载机制与JVM优化&lt;/a>&lt;br>
&lt;a class="link" href="https://leibnizhu.github.io/p/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%ba%94.%e7%bb%88%e7%ab%a0Java%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8/%e4%bc%98%e5%8c%96/" >《深入理解Java虚拟机》 学习笔记(五.终章)——Java内存模型与线程安全/优化&lt;/a>&lt;/p>
&lt;h2 id="类加载机制">类加载机制&lt;/h2>
&lt;p>&lt;img src="https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/8.png"
width="737"
height="210"
srcset="https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/8_hu869176d3a01388de7dd81ab41b02155c_8084_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/8_hu869176d3a01388de7dd81ab41b02155c_8084_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="350"
data-flex-basis="842px"
>
类从加载导卸载出内存的整个生命周期如上图所示。图中的7个阶段中，加载、验证、准备、初始化和卸载的顺序是确定的，而解析和使用阶段不一定，解析可能在初始化之后（动态绑定）。&lt;/p>
&lt;h3 id="类加载时机">类加载时机&lt;/h3>
&lt;p>&lt;strong>有且只有&lt;/strong>以下5种情况：&lt;/p>
&lt;ol>
&lt;li>遇到new、getstatic、putstatic、invokestatic等字节码，对应Java代码中的new对象、读取或者设置类的静态变量、调用类的静态方法；&lt;/li>
&lt;li>使用reflect包进行反射的时候；&lt;/li>
&lt;li>初始化类时，若父类未初始化，则先出发父类的初始化；&lt;/li>
&lt;li>JVM启动时，执行的主类（包含main()方法的类）；&lt;/li>
&lt;li>JDK1.7以后动态语言支持。&lt;/li>
&lt;/ol>
&lt;p>注意是有且仅有，其他情况，譬如数组定义引用到未加载的类、调用类的静态常量（存储在常量池中）等其他情况并不会触发类的初始化加载。&lt;/p>
&lt;h3 id="加载">加载&lt;/h3>
&lt;p>完成以下事情：&lt;/p>
&lt;ol>
&lt;li>通过类的全限定名获取类的二进制字节流（不一定从文件获取，也可能是从网络、zip包、动态代理、其他文件如jsp等途径生成）；&lt;/li>
&lt;li>将字节流的静态存储结构转化为方法区的运行时数据结构，具体由虚拟机自行实现定义；&lt;/li>
&lt;li>生成对应java.lang.Class对象，放在方法区。&lt;/li>
&lt;/ol>
&lt;p>数组类本身不通过类加载器创建，而是JVM直接创建的，如果数组类加载的时候，其组件类型（去掉最外面维度之后的类型）是引用类型，则递归地加载。&lt;br>
加载阶段和连接阶段的部分内容（比如一部分字节码文件格式的验证动作）时交叉进行的，但两者的开始时间肯定是保持先后顺序的。&lt;/p>
&lt;h3 id="验证">验证&lt;/h3>
&lt;p>验证步骤是为了确保Class文件的字节流中的信息符合JVM要求，且不危害JVM安全。验证过程又细分为以下4个子过程：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>文件格式验证&lt;/strong>：验证是否符合Class文件格式，如果验证到不符合Class文件格式约束，则JVM抛出java.lang.VerifyError异常或其子类；&lt;/li>
&lt;li>&lt;strong>元数据验证&lt;/strong>:进行语义分析，保证其符合Java语言规范；&lt;/li>
&lt;li>&lt;strong>字节码验证&lt;/strong>：通过数据流和控制流分析，确认语义合法且符合逻辑。JDK1.6之后的javac在Code属性的属性表里面增加了一项“StackMapTable”属性，描述了方法提中所有基本块（按控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，字节码验证过程中秩序检查StackMapTable属性的记录是否合法即可；&lt;/li>
&lt;li>&lt;strong>符号引用验证&lt;/strong>：在连接的第三阶段——解析阶段中，JVM将符号引用转化为直接引用进行符号引用验证，对类自身以外的信息进行匹配行校验，比如符号引用的类是否能找到，类、方法、字段的访问性是否能被当前类访问。&lt;/li>
&lt;/ol>
&lt;h3 id="准备">准备&lt;/h3>
&lt;p>为类的静态变量分配内存，并初始化其值（初始化为零值）。如果有定义其取值，且非final变量，比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> String test &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#48b685">&amp;#34;test&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>test变量不是final变量，会被初始化为零值null，在初始化阶段调用&amp;lt;clinit&amp;gt;方法时才会赋值&amp;quot;test&amp;quot;。&lt;br>
而一个final的静态变量，即常量，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> String test &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#48b685">&amp;#34;test&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>是会通过ConstantValue属性在准备阶段就初始化为&amp;quot;test&amp;quot;。&lt;/p>
&lt;h3 id="解析">解析&lt;/h3>
&lt;p>JVM将常量池的符号引用替换为直接引用的过程。JVM规范要求在调用符号引用操作的字节码指令之前必须先对其所使用的符号引用进行解析。JVM会将第一次解析结果进行缓存，避免解析动作重复进行。&lt;/p>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;p>初始化是类加载过程的最后一步，执行类构造器&amp;lt;clinit&amp;gt;()方法。&lt;br>
&amp;lt;clinit&amp;gt;方法由编译器自动收集类中所有静态变量的赋值动作以及静态代码块合并生成的，按源文件中出现的顺序（即静态代码块对于其后的静态变量，可以赋值，但不能访问）。&amp;lt;clinit&amp;gt;方法不需要调用父类的类构造器，JVM会保证&amp;lt;clinit&amp;gt;执行前父类的&amp;lt;clinit&amp;gt;方法已经执行，所以JVM第一个执行的&amp;lt;clinit&amp;gt;方法是Object的。JVM会保证多线程环境中&amp;lt;clinit&amp;gt;方法执行的安全性，保证只有一个线程去执行。&lt;br>
&amp;lt;clinit&amp;gt;方法不是必须的，比如没有静态变量的接口，或没有静态代码块和静态变量的类。&lt;/p>
&lt;h2 id="编译期优化">编译期优化&lt;/h2>
&lt;p>javac对代码的运行效率几乎没有任何优化措施（JDK1.3之后-O优化参数没有意义了），性能优化主要集中在运行期（后端的即时编译期），javac主要进行了一些针对Java语言编码过程的优化，如语法糖。&lt;/p>
&lt;h3 id="编译过程">编译过程&lt;/h3>
&lt;p>编译过程大概分为3个过程：
&lt;img src="https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/9.png"
width="1306"
height="123"
srcset="https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/9_hub3b3d3b47598e5c2da162c1d89b967a1_11406_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/9_hub3b3d3b47598e5c2da162c1d89b967a1_11406_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1061"
data-flex-basis="2548px"
>
javac中的代码是这样的：
&lt;img src="https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/10.png"
width="819"
height="460"
srcset="https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/10_hufd3f342c03009d08f18a4b1b1ada6259_23374_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EJVM%E4%BC%98%E5%8C%96/10_hufd3f342c03009d08f18a4b1b1ada6259_23374_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="178"
data-flex-basis="427px"
>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>解析与填充符号表&lt;/strong>过程：首先进行词法、语法分析，将源代码的字符流转换为Token集合，然后根据Token序列构造抽象语法树AST，对应parseFiles()方法；然后填充符号表（记录符号地址和符号信息映射关系），符号表中记录的信息在编译的不同阶段都会用到，对应enterTress()方法；&lt;/li>
&lt;li>插入式注解处理器的&lt;strong>注解处理&lt;/strong>过程：处理代码中的注解，这个过程中可能影响到语法树的元素，如果影响到了，则要重新回到解析及填充符号表的过程，这样一个循环称作一个Round，直到注解处理器没有对语法树进行修改；&lt;/li>
&lt;li>&lt;strong>分析与字节码生成&lt;/strong>过程：具体又分为&lt;strong>标注检查&lt;/strong>（检查变量使用前是否已生命、变量与赋值之间类型是否匹配等问题，以及常量折叠，如&amp;quot;1&amp;quot;+&amp;ldquo;2&amp;quot;优化为&amp;quot;12&amp;rdquo;）、&lt;strong>数据及控制流分析&lt;/strong>（检查局部变量使用前是否赋值、每条路径是否都有返回值、异常是否都处理了等问题）、&lt;strong>解语法糖&lt;/strong>（由desugar()方法完成）、&lt;strong>字节码生成&lt;/strong>（收敛生成&amp;lt;clinit&amp;gt;()方法he &amp;lt;init&amp;gt;()方法，将所有生成的信息转换成字节码写入磁盘）等子过程。&lt;/li>
&lt;/ol>
&lt;h3 id="语法糖">语法糖&lt;/h3>
&lt;h4 id="泛型">泛型&lt;/h4>
&lt;p>Java的泛型是伪泛型，只在源码中存在，编译时进行类型擦除变成原生类型（Raw Type），并在调用的地方加上强转类型代码，这是为了兼容旧版本。对于重载方法，如果泛型参数的泛型类型不同而其他参数以及返回类型相同，是不允许重载的，比如以下方法1和方法2不能重载；而如果泛型参数的泛型类型不同，且返回类型不同，则可以重载，比如方法1和方法3（JVM本来就允许）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//方法1和方法2不能重载，方法1和方法3可以重载
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//方法1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> String &lt;span style="color:#06b6ef">test&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>List&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>Integer&lt;span style="color:#5bc4bf">&amp;gt;);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//方法2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> String &lt;span style="color:#06b6ef">test&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>List&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">//方法3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">test&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>List&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="自动装箱拆箱遍历循环变长参数">自动装箱/拆箱、遍历循环、变长参数&lt;/h4>
&lt;p>遍历循环（增强for）的实现是编译时还原为迭代其的实现，因此需要实现Iterable接口。&lt;/p>
&lt;h4 id="条件编译">条件编译&lt;/h4>
&lt;p>java的条件编译通过条件为常量的if语句实现。如下面代码中，编译后的字节码不会包含调用B()方法的指令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#815ba4">true&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span> &lt;span style="color:#815ba4">else&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> B&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="运行期优化">运行期优化&lt;/h2>
&lt;h3 id="解释器与编译器">解释器与编译器&lt;/h3>
&lt;p>许多主流商用JVM包括HotSpot采用解释器与编译器并存的结构，启动的时候使用解释器，保证启动速度，随着运行时间推移，编译器发挥作用，编译为本地代码，提高执行效率。在JVM中这种模式被称为混合模式，可以用&lt;code>-Xint&lt;/code>强制JVM运行于解释模式，或用&lt;code>-Xcomp&lt;/code>强制JVM运行于编译模式。HotSpot包含两个及时编译器Client Compiler和Server Compiler，一般简称为C1和C2。&lt;/p>
&lt;h3 id="热点探测">热点探测&lt;/h3>
&lt;p>运行过程中被即时编译器编译的&lt;strong>热点代码&lt;/strong>包括被多次调用的 &lt;strong>方法&lt;/strong> 或 &lt;strong>循环体&lt;/strong>，对于后者编译器还是会以整个方法作为编译对象。&lt;br>
判断方法或循环体是否热点代码的行为被称为&lt;strong>热点探测&lt;/strong>，目前主要的热点探测方法有两种：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>基于采样的热点探测&lt;/strong>。JVM周期性的检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那么就是热点方法。缺点是容易收到线程阻塞或其他外界因素影响，优点是简单高效；&lt;/li>
&lt;li>&lt;strong>基于计数器的热点探测&lt;/strong>。为每个方法甚至代码块建立计数器，统计执行次数，超过一定阈值就认为是热点方法。缺点是不能获取导方法的调用关系，优点是精确且严谨。&lt;/li>
&lt;/ol>
&lt;p>HotSpot使用第二种，准备了&lt;strong>方法调用计数器&lt;/strong>和&lt;strong>回边计数器&lt;/strong>。前者统计方法被调用的次数，默认的阈值：Client模式1500次，Server模式10000次，可以通过&lt;code>-XX:CompileThreshold&lt;/code>来设定；后者统计循环体被执行的次数，字节码遇到控制流向后跳转的指令称为回边(Back Edge)，通过&lt;code>-XX:BackEdgeThreshold&lt;/code>来手动设置阈值。&lt;br>
对于方法调用计数器，一个方法执行时先判断存不存在JIT编译过的版本，存在的话执行编译后版本，不存在的话计数器加一，再判断是否超过阈值，超过的话向即时编译器提交编译申请。其统计的并不是方法被调用的绝对次数，而是一段时间内的调用次数，如果超过一定时间计数器仍不足阈值，则计数值会减少一半，这被成为&lt;strong>热度衰减&lt;/strong>(Counter Decay)，这段时间被称为半衰期。热度衰减的动作时在GC时顺便进行的。&lt;br>
回边计数器没有计数热度衰减的过程，记录循环体被调用的绝对次数。&lt;br>
默认配置下，编译是在后台的编译线程进行的，除非用&lt;code>-XX:-BackgroundCompilation&lt;/code>来禁止后台编译，这样提交编译请求的线程会一直等待编译完成。&lt;/p>
&lt;h3 id="编译优化技术">编译优化技术&lt;/h3>
&lt;p>JVM几乎所有的优化措施都集中在及时编译器中。&lt;/p>
&lt;h4 id="方法内联">方法内联&lt;/h4>
&lt;p>方法内联（Method Inlining）指的是将调用的方法代码替换掉调用者的调用语句。目的：&lt;/p>
&lt;ol>
&lt;li>取出调用方法的成本，如建立栈帧；&lt;/li>
&lt;li>为其他优化建立良好基础，比如内联可以发现更多的无用代码。&lt;/li>
&lt;/ol>
&lt;p>考虑到多态，方法内联的实现并不简单，在编译器无法得出调用的方法是哪个版本的结论（父类还是子类），需要在运行期确定。&lt;br>
JVM引入了类型继承关系分析（Class Hierarchy Analysis，CHA）技术，用于确定目前加载的类中某个接口是否有多于一种的实现、某类是否存在子类、子类是否抽象等信息。进行内联时：&lt;/p>
&lt;ol>
&lt;li>如果目标方法是非虚方法（私有方法、实力构造器、父类方法、静态方法等），那么直接进行内联；&lt;/li>
&lt;li>对于虚方法，向CHA查询该方法是否有多个版本可选，如果只有一个版本，则直接进行内联，此时属于激进优化，需要预留逃生门（守护内联），此后如果JVM没有加载到改变方法接受者的继承关系的类，则可以继续使用内联优化的版本，否则抛弃已编译的代码、退回到解释状态进行或重新编译；&lt;/li>
&lt;li>如果虚方法有多个版本，则尝试内联缓存（Inline Cache）。发生方法调用前，内联缓存状态为空；第一次调用后，缓存记录下方法接受者的版本信息，每次进行方法调用的时候都比较接受者版本，如果方法接受者版本一样，则继续调用内联缓存进行内联，否则取消内联。&lt;/li>
&lt;/ol>
&lt;h4 id="冗余访问消除">冗余访问消除&lt;/h4>
&lt;p>冗余访问消除（Redundant Loads Elimination）指的是如果能保证一个方法的两次调用之间的代码不会引起其返回值的更改，那么这第二次调用的结果可以直接用第一次调用结果去赋值，比如一下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">foo1&lt;/span>&lt;span style="color:#5bc4bf">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y&lt;span style="color:#5bc4bf">=&lt;/span>b&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">value&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//其他调用，不会影响b.value的返回值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> z&lt;span style="color:#5bc4bf">=&lt;/span>b&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">value&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上代码可以优化为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">foo1&lt;/span>&lt;span style="color:#5bc4bf">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y&lt;span style="color:#5bc4bf">=&lt;/span>b&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">value&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//其他调用，不会影响b.value的返回值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> z&lt;span style="color:#5bc4bf">=&lt;/span>y&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="复写传播">复写传播&lt;/h4>
&lt;p>复写传播（Copy Propagation）指的是去掉重复的变量。&lt;/p>
&lt;h4 id="无用代码消除">无用代码消除&lt;/h4>
&lt;p>无用代码消除（Dead Code Elimination），无用代码指的是永远不会izhixing的代码，或者完全没有意义的代码。&lt;/p>
&lt;h4 id="公共子表达式消除">公共子表达式消除&lt;/h4>
&lt;p>Common Subexpression Elimination定义：一个表达式E已经计算过，且计算后到现在E的变量全部没有变化，那么E这次出现成为了公共子表达式，无需重复计算，直接用前面计算结果替换即可。如果消除优化仅限于程序基本块内，则成为局部公共子表达式消除，如果覆盖范围涵盖多个基本块，则成为全局公共子表达式消除。&lt;/p>
&lt;h4 id="数组边界检查消除">数组边界检查消除&lt;/h4>
&lt;p>Java访问数组元素时，会对下标进行上下界范围检查，不满足上下界时会抛出ArrayIndexOutOfBoundsException异常。&lt;br>
编译器根据数据流分析确定数组长度，并判断下标有无越界；在循环中进行数组访问时，也是可以通过数据流分析判定循环变量的取值是否越界，如果能保证循环体中不越界的话循环体中访问数组的语句可以消除边界检查。&lt;br>
还有一种思路时隐式异常处理，将空指针检查和除数为零检查消除，注册一个Segment Fault信号的异常处理器，放在异常处理里面，在这个异常处理器里面再转换为对应的异常并抛出。&lt;br>
还有一些其他的消除操作，比如自动装箱消除、安全点消除、消除反射等等。&lt;/p>
&lt;h4 id="逃逸分析">逃逸分析&lt;/h4>
&lt;p>逃逸分析不能直接优化代码，而是为其他优化手段提供优化的依据。逃逸分析指的是分析对象动态作用域：一个对象在方法中被定义后，被外部方法引用，则称为&lt;strong>方法逃逸&lt;/strong>，被外部线程引用访问到的话，被称为&lt;strong>线程逃逸&lt;/strong>。如果能证明一个对象不会逃逸到方法或线程外，则可以进行以下优化：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>栈上分配&lt;/strong>（Stack Allocation）：若确认对象没有方法逃逸，可以将其在栈上分配内存，则其占用内存会随着栈帧出栈而被销毁，减少GC压力，而一般应用中不逃逸的局部对象占很大比例；&lt;/li>
&lt;li>&lt;strong>同步消除&lt;/strong>（Synchronization Elimination）：若确认对象没有线程逃逸，可以对该变量实时的同步措施消除；&lt;/li>
&lt;li>&lt;strong>标量替换&lt;/strong>（Scalar Replacement）：&lt;strong>标量&lt;/strong>指一个数据无法再分解为更小的数据来表示，如基础数据类型，反之称之为&lt;strong>聚合量&lt;/strong>（Aggregate），如对象。若确认一个对象没有逃逸，则可以不创建对象，改为直接创建它会被使用到的成员变量来代替，同时可以保存在栈上，提高读写效率，并为进一步优化创造条件。&lt;/li>
&lt;/ol></description></item><item><title>Redis性能调优——Pipeline、主从复制、Lua脚本等</title><link>https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/</link><pubDate>Sat, 26 Nov 2016 14:01:02 +0800</pubDate><guid>https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/</guid><description>&lt;p>这篇也是组内分享的文档，整理了之前两篇Netty+Redis的文章，加入了一些Redis调优相关的命令和内容。&lt;/p>
&lt;h2 id="redis性能瓶颈">Redis性能瓶颈&lt;/h2>
&lt;h3 id="tcp连接">TCP连接&lt;/h3>
&lt;p>Redis协议基于TCP/IP协议，受限于TCP连接建立的速度（三次握手等），及网络中数据传输的速度。&lt;/p>
&lt;h3 id="数据包大小">数据包大小&lt;/h3>
&lt;p>Redis官方的一项测试显示，对于1k~10k以下的数据，Redis的吞吐量变化并不明显，吞吐量曲线在1k~10k左右出现拐点，如下图。&lt;br>
&lt;img src="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/1.png"
width="662"
height="461"
srcset="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/1_huae3739b158ac574ede9203810d0e3c4f_14804_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/1_huae3739b158ac574ede9203810d0e3c4f_14804_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="344px"
>&lt;/p>
&lt;h3 id="单线程">单线程&lt;/h3>
&lt;p>Redis服务器为C语言编写，使用异步非阻塞IO，目前坚持使用单线程（可能出于线程锁的效率考虑）。对于高并发访问+多核CPU场景而言，并不能充分使用CPU资源，可能发生某核心占用率很高，其他核心空闲，但Redis请求阻塞在队列中的情况。&lt;br>
搭建Redis集群可以解决该问题，但集群节点间访问引起的网络IO延时又带来新的问题。&lt;/p>
&lt;h2 id="redis性能监控测试">Redis性能监控/测试&lt;/h2>
&lt;h3 id="info命令">info命令&lt;/h3>
&lt;p>redis-cli中输入info可以显示当前Redis服务器的全部状态信息。这些信息按照内容被分成了很多部分，可以用额外的参数来单独获取，如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">参数名&lt;/th>
&lt;th style="text-align:left">说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">server&lt;/td>
&lt;td style="text-align:left">获取 server 信息，包括 version, OS, port 等信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">clients&lt;/td>
&lt;td style="text-align:left">获取 clients 信息，如客户端连接数等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">memory&lt;/td>
&lt;td style="text-align:left">获取 server 的内存信息，包括当前内存消耗、内存使用峰值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">persistence&lt;/td>
&lt;td style="text-align:left">获取 server 的持久化配置信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">stats&lt;/td>
&lt;td style="text-align:left">获取 server 的一些基本统计信息，如处理过的连接数量等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">replication&lt;/td>
&lt;td style="text-align:left">获取 server 的主从配置信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">cpu&lt;/td>
&lt;td style="text-align:left">获取 server 的 CPU 使用信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">keyspace&lt;/td>
&lt;td style="text-align:left">获取 server 中各个 DB 的 key 的数量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">cluster&lt;/td>
&lt;td style="text-align:left">获取集群节点信息，仅在开启集群后可见&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">commandstats&lt;/td>
&lt;td style="text-align:left">获取每种命令的统计信息，非常有用&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="slowlog命令">slowlog命令&lt;/h3>
&lt;p>redis.conf中配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> slowlog-log-slower-than &lt;span style="color:#f99b15">10000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slowlog-max-len &lt;span style="color:#f99b15">128&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>意为：如果一条命令的响应时间超过了 10000us (即 10ms) ，那么将会作为 &amp;ldquo;slow command&amp;rdquo; 被记录，并且将只保留最新的128条记录。&lt;br>
在redis-cli中使用slowlog get N可以显示最新产生的N条慢操作：&lt;br>
&lt;img src="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/2.png"
width="278"
height="91"
srcset="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/2_hue73097dbe905c3b1c2195a46cef04135_3972_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/2_hue73097dbe905c3b1c2195a46cef04135_3972_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="305"
data-flex-basis="733px"
>&lt;br>
每条语句有四个描述字段，分别表示慢日志序号（最新的记录被展示在最前面）、这条记录被记录时的时间戳、这条命令的响应时间（单位：us 微秒）、这条命令的内容。&lt;br>
可以根据slowlog的记录优化对应的语句。&lt;/p>
&lt;h3 id="bigkeys命令">bigkeys命令&lt;/h3>
&lt;p>使用方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>redis-cli -h &amp;lt;host&amp;gt; -p &amp;lt;port&amp;gt; --bigkeys
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这条命令会从指定的 Redis DB 中持续采样，实时输出当时得到的 value 占用空间最大的 key 值，并在最后给出各种数据结构的 biggest key 的总结报告，如下图：&lt;br>
&lt;img src="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/3.png"
width="673"
height="646"
srcset="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/3_hub089a628b13afa38bffb2e2c4121c535_64570_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/3_hub089a628b13afa38bffb2e2c4121c535_64570_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="250px"
>&lt;/p>
&lt;h3 id="latency命令">latency命令&lt;/h3>
&lt;p>使用方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>redis-cli -h &amp;lt;host&amp;gt; -p &amp;lt;port&amp;gt; --latency-history
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>redis-cli -h &amp;lt;host&amp;gt; -p &amp;lt;port&amp;gt; --latency
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>区别仅在于：前者每隔15秒生成一条记录（这15秒内的测试结果），后者持续更新测试结果，如下图：&lt;br>
&lt;img src="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/4.png"
width="652"
height="133"
srcset="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/4_hu8eb1b28e9fc83dee92cfb5f4d9720d49_15842_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/4_hu8eb1b28e9fc83dee92cfb5f4d9720d49_15842_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="490"
data-flex-basis="1176px"
>&lt;/p>
&lt;h3 id="redis-benchmark测试">redis-benchmark测试&lt;/h3>
&lt;p>使用方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>redis-benchmark -h &amp;lt;host&amp;gt; -p &amp;lt;port&amp;gt; -c &amp;lt;并发数&amp;gt; -n &amp;lt;请求次数&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行后，redis-benchmark会对各个命令分别进行测试，测试结果较长，在此截取部分如下：&lt;br>
&lt;img src="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/5.png"
width="348"
height="214"
srcset="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/5_hu3a941fce91b3a5aed7470d18b62238b8_6920_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/5_hu3a941fce91b3a5aed7470d18b62238b8_6920_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="390px"
>&lt;/p>
&lt;h3 id="第三方统计分析工具redis-stat">第三方统计分析工具redis-stat&lt;/h3>
&lt;p>redis-stat采用ruby开发，利用redis-cli info 提供的原始数据，给用户提供基于文本列表或web图表方式展现的各种关键数据。
redis-stat 开源网址: &lt;a class="link" href="https://github.com/junegunn/redis-stat" target="_blank" rel="noopener"
>https://github.com/junegunn/redis-stat&lt;/a>&lt;br>
&lt;img src="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/6.png"
width="687"
height="366"
srcset="https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/6_hu80e03b156dadeb75c088820daa26894d_25906_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98Pipeline%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6Lua%E8%84%9A%E6%9C%AC%E7%AD%89/6_hu80e03b156dadeb75c088820daa26894d_25906_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="450px"
>&lt;/p>
&lt;h2 id="redis性能调优">Redis性能调优&lt;/h2>
&lt;h3 id="使用pipeline">使用Pipeline&lt;/h3>
&lt;p>对于Redis读写，有很大一部分的耗时是在网络IO上，尤其是Redis(集群)与应用不在一台服务器上时；此时，对于一些连续的操作，尽量使用pipeline批处理。若批量的命令使用到的key要求在执行过程中不被其他请求修改，则需要用redis事务，效率还是比pipeline低。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Jedis jedis &lt;span style="color:#5bc4bf">=&lt;/span> RedisUtils&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">getSingleJedis&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#815ba4">false&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//获取Jedis连接
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>Pipeline pl &lt;span style="color:#5bc4bf">=&lt;/span> jedis&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">pipelined&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>&lt;span style="color:#776e71">//获取Pipeline
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>Response&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> resp1 &lt;span style="color:#5bc4bf">=&lt;/span> pl&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#ef6155">“&lt;/span>key1&lt;span style="color:#ef6155">”&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//Pipeline压入命令并保存Response引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>Response&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> resp2 &lt;span style="color:#5bc4bf">=&lt;/span> pl&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#ef6155">“&lt;/span>key2&lt;span style="color:#ef6155">”&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pl&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">sync&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>&lt;span style="color:#776e71">//Pipeline执行批处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">out&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">println&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#ef6155">“&lt;/span>key1&lt;span style="color:#ef6155">’&lt;/span>s value &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#ef6155">”&lt;/span> &lt;span style="color:#5bc4bf">+&lt;/span> resp1&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">());&lt;/span>&lt;span style="color:#776e71">//从Response获取执行结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">out&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">println&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#ef6155">“&lt;/span>key2&lt;span style="color:#ef6155">’&lt;/span>s value &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#ef6155">”&lt;/span> &lt;span style="color:#5bc4bf">+&lt;/span> resp2&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RedisUtils&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">close&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>pl&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//关闭Pipeline
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>RedisUtils&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">close&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>jedis&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//关闭Jedis连接
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要注意的是Pipeline一次传输的key或数据也不宜过多，参考本文1.2小节。&lt;/p>
&lt;h3 id="使用lua脚本">使用Lua脚本&lt;/h3>
&lt;p>灵活利用Lua脚本，可减少Redis的网络IO。Redis支持在服务器上运行Lua脚本完成一些简单运算。Redis尽管对Lua脚本有很多限制，但的确能提高效率，对于一些Redis原生API不能满足的批量操作，比如读取多个key再进行简单计算，如果将这些key的值分别读取到本地，再进行计算，会发生多次网络IO，那么可以用上面的pipeline，而效率更高的方法是将这些计算写成Lua脚本。&lt;br>
我们的RTB目前使用Lua脚本的流程如下：&lt;/p>
&lt;ol>
&lt;li>配置一个监听Servlet上下文初始化的Listener（com.turingdi.rtb.service. PropertiesLoadListener），执行读取配置文件、Redis连接等初始化操作；&lt;/li>
&lt;li>/该Listener初始化Redis时，将指定的多个Lua脚本文件读入内存（com.turingdi.rtb.utils.RedisUtils的loadScripts()）；&lt;/li>
&lt;li>使用Redis的SCRIPTLOAD命令，将Lua脚本加载到Redis服务器，返回一个SHA码，保存到RedisUtils类中；&lt;/li>
&lt;li>竞价过程中需要调用Lua脚本时，调用Redis的EVALSHA命令，使用初始化时拿到的SHA进行Lua脚本调用，返回计算结果。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-lua" data-lang="lua">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">--计算QPS，QPS这个key只保留1s，不存在的时候设置为1并设置生命周期为1，存在的时候直接加1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">local&lt;/span> isExist &lt;span style="color:#5bc4bf">=&lt;/span> redis.call(&lt;span style="color:#48b685">&amp;#39;EXISTS&amp;#39;&lt;/span>, &lt;span style="color:#48b685">&amp;#39;QPS&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">if&lt;/span> isExist &lt;span style="color:#5bc4bf">==&lt;/span> &lt;span style="color:#f99b15">0&lt;/span> &lt;span style="color:#815ba4">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> redis.call(&lt;span style="color:#48b685">&amp;#39;INCR&amp;#39;&lt;/span>, &lt;span style="color:#48b685">&amp;#39;QPS&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> redis.call(&lt;span style="color:#48b685">&amp;#39;EXPIRE&amp;#39;&lt;/span>, &lt;span style="color:#48b685">&amp;#39;QPS&amp;#39;&lt;/span>, &lt;span style="color:#48b685">&amp;#39;1&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> redis.call(&lt;span style="color:#48b685">&amp;#39;INCR&amp;#39;&lt;/span>, &lt;span style="color:#48b685">&amp;#39;QPS&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">--处理请求数和响应数的统计&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>redis.call(&lt;span style="color:#48b685">&amp;#39;INCR&amp;#39;&lt;/span>, KEYS[&lt;span style="color:#f99b15">1&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">if&lt;/span> ARGV[&lt;span style="color:#f99b15">1&lt;/span>] &lt;span style="color:#5bc4bf">==&lt;/span> &lt;span style="color:#48b685">&amp;#39;1&amp;#39;&lt;/span> &lt;span style="color:#815ba4">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> redis.call(&lt;span style="color:#48b685">&amp;#39;INCR&amp;#39;&lt;/span>, KEYS[&lt;span style="color:#f99b15">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本文不对Lua脚本进行详细阐述，有需要的可以参照以下网页/文档：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="http://redisdoc.com/script/index.html" target="_blank" rel="noopener"
>http://redisdoc.com/script/index.html&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.oschina.net/translate/intro-to-lua-for-redis-programmers" target="_blank" rel="noopener"
>https://www.oschina.net/translate/intro-to-lua-for-redis-programmers&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://origin.redisbook.com/feature/scripting.html" target="_blank" rel="noopener"
>http://origin.redisbook.com/feature/scripting.html&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://wiki.jikexueyuan.com/project/redis/lua.html" target="_blank" rel="noopener"
>http://wiki.jikexueyuan.com/project/redis/lua.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="使用本地的redis">使用本地的Redis&lt;/h3>
&lt;p>Redis尽量放在本地，减少网络IO时间；对相应时间要求高的，尽量不要用云服务商提供的Redis服务，读写速度比不上本地的。&lt;/p>
&lt;h3 id="主从复制读写分离">主从复制/读写分离&lt;/h3>
&lt;p>Redis放在本地，在服务器集群环境下就有数据同步的问题。之前尝试过很多方案，Redis自己的Ruby集群、Twitter的Twemproxy等等，都不适合RTB使用——这些集群更多地考虑可用性和数据分片、扩容性，但对一些多键操作支持很差，而且也有各种缺陷（如使用Redis自带的Ruby集群，至少3主3从，可以建好3主3从的集群之后，手动移动Slot到同一台主机，删除其他主机，变成1主3从，但这个集群一旦关闭就无法启动）。&lt;br>
考虑到RTB使用的Redis读多写少，所以最后使用的方案是Redis自带的主从复制，集群的不同的服务器之间只需要一台主机作为Redis主机，其他服务器的Redis服务设置slaveof属性，作为其从机。此外，可以将从机的只读属性设为no，但往Slave写入的数据会在下一次同步的时候被Master的数据所覆盖——这样做的目的在于写入一些临时缓存变量。&lt;br>
redis.conf配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> slaveof &amp;lt;Master IP&amp;gt; &amp;lt;Master端口&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slave-read-only no
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>只有一台服务器的情况下，如果是多核服务器（16核及以上），由于Redis是单线程的，只能利用一个CPU内核，只开一个Redis服务实例可能压力很大（可以从CPU占用看出来），此时也可以使用上面提到的主从复制功能，在同一台服务器上开启多个Redis实例分担查询压力，提高并发性能。&lt;br>
Linux系统中，可以使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>taskset -cp &lt;span style="color:#5bc4bf">[&lt;/span>CPU核心号码，从0开始&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">[&lt;/span>要执行的命令&lt;span style="color:#5bc4bf">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来指定要执行的命令在哪些CPU内核上运行，在多核服务器上，可以合理利用此命令来分配CPU资源，如指定多个Redis和Netty分别运行在多个内核上，并指定哪个Netty服务使用哪个Redis服务（需要自己编写Netty服务，读取配置文件，使用不同端口的Redis服务），避免资源浪费和拥挤。&lt;br>
目前RTB在一台服务器上部署了一个Master节点（端口6660）和5个Slave节点（端口6661-6665），即只有一个对外可写入的Redis服务，其他Redis服务只能读，保证了读的性能。启动的脚本如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>kill -9 &lt;span style="color:#815ba4">$(&lt;/span>ps -ef | grep redis-server | grep -v grep | awk &lt;span style="color:#48b685">&amp;#39;{print $2}&amp;#39;&lt;/span>&lt;span style="color:#815ba4">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd /usr/local/redis/6660
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>taskset -c &lt;span style="color:#f99b15">0&lt;/span> redis-server redis.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd /usr/local/redis/6661
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>taskset -c &lt;span style="color:#f99b15">1&lt;/span> redis-server redis.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>…………
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd /usr/local/redis/6665
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>taskset -c &lt;span style="color:#f99b15">5&lt;/span> redis-server redis.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="计算缓存">计算缓存&lt;/h3>
&lt;p>Redis指令的优化及自定义计算缓存。利用SLOWLOG我们可以找到执行比较慢的命令，从而进行优化。&lt;br>
比如RTB系统在测试一段时间之后，通过SLOWLOG命令得知耗时较长的都是用户人群标签的并集操作，而这个操作与请求的具体内容有关。所以后来设定了一个计算缓存，通过EXPIRE命令设置缓存的生命周期（随着时间推移，人群标签的计算结果是不一样的，需要定时更新），每次新的请求在计算这一步时，先查询缓存中是否存在计算结果，存在的话直接读取，不存在（全新的计算或旧的已过期）则重新计算并放入运算缓存。（详见com.turingdi.rtb.service.CampaignService）&lt;/p>
&lt;h3 id="压缩key和value">压缩key和value&lt;/h3>
&lt;p>在数据量大的情况下，压缩key和value的长度不管对存储还是网络传输都有利。&lt;/p></description></item></channel></rss>