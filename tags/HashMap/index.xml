<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HashMap on Heaven's Door</title><link>https://leibnizhu.github.io/tags/HashMap/</link><description>Recent content in HashMap on Heaven's Door</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 01 Aug 2017 16:36:39 +0800</lastBuildDate><atom:link href="https://leibnizhu.github.io/tags/HashMap/index.xml" rel="self" type="application/rss+xml"/><item><title>HashMap线程安全性讨论</title><link>https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/</link><pubDate>Tue, 01 Aug 2017 16:36:39 +0800</pubDate><guid>https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/</guid><description>&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/sundown.png" alt="Featured image of post HashMap线程安全性讨论" />&lt;h1 id="hashmap线程安全性讨论">HashMap线程安全性讨论&lt;/h1>
&lt;p>去年写的 &lt;a class="link" href="https://leibnizhu.github.io/2016/12/24/HashMap%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0/" >HashMap源码阅读笔记&lt;/a> 分析了JDK8 中的&lt;code>HashMap&lt;/code>源码的&lt;code>get()&lt;/code>和&lt;code>put()&lt;/code>两大方法，当时并没有考虑到&lt;code>HashMap&lt;/code>的线程安全性。&lt;br>
众所周知，&lt;code>HashMap&lt;/code>并非线程安全的，但在 &lt;em>JDK8&lt;/em> 之前，&lt;code>HashMap&lt;/code>的线程安全不但体现在多线程读写可能出现数据错误，还存在一个多线程扩容导致的死循环Bug。本文将讨论这一Bug，及在 &lt;em>JDK8&lt;/em> 中的修复，以及相关的&lt;code>ConcurrentHashMap&lt;/code>。&lt;/p>
&lt;h2 id="jdk8-之前的多线程扩容bug">&lt;em>JDK8&lt;/em> 之前的多线程扩容Bug&lt;/h2>
&lt;h3 id="扩容代码解析">扩容代码解析&lt;/h3>
&lt;p>我们直接看JDK7 中&lt;code>HashMap&lt;/code>的扩容方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">resize&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> newCapacity&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">[]&lt;/span> oldTable &lt;span style="color:#5bc4bf">=&lt;/span> table&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fec418">int&lt;/span> oldCapacity &lt;span style="color:#5bc4bf">=&lt;/span> oldTable&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">length&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//最大长度限制在Integer.MAX_VALUE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>oldCapacity &lt;span style="color:#5bc4bf">==&lt;/span> MAXIMUM_CAPACITY&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threshold &lt;span style="color:#5bc4bf">=&lt;/span> Integer&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">MAX_VALUE&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">[]&lt;/span> newTable &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">new&lt;/span> Entry&lt;span style="color:#5bc4bf">[&lt;/span>newCapacity&lt;span style="color:#5bc4bf">];&lt;/span>&lt;span style="color:#776e71">//按新的长度分配哈希表数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> transfer&lt;span style="color:#5bc4bf">(&lt;/span>newTable&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//将旧的哈希表重新分配到新哈希表里，可能导致环链
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> table &lt;span style="color:#5bc4bf">=&lt;/span> newTable&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//将新的哈希表复制到HashMap的table变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> threshold &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span>&lt;span style="color:#5bc4bf">)(&lt;/span>newCapacity &lt;span style="color:#5bc4bf">*&lt;/span> loadFactor&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//按新容量更新扩容阈值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">transfer&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Entry&lt;span style="color:#5bc4bf">[]&lt;/span> newTable&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">[]&lt;/span> src &lt;span style="color:#5bc4bf">=&lt;/span> table&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fec418">int&lt;/span> newCapacity &lt;span style="color:#5bc4bf">=&lt;/span> newTable&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">length&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">for&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> j &lt;span style="color:#5bc4bf">=&lt;/span> 0&lt;span style="color:#5bc4bf">;&lt;/span> j &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span> src&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">length&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span> j&lt;span style="color:#5bc4bf">++)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> e &lt;span style="color:#5bc4bf">=&lt;/span> src&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>e &lt;span style="color:#5bc4bf">!=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> src&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//关键部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">do&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> next &lt;span style="color:#5bc4bf">=&lt;/span> e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//获得原来链表中的下一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#fec418">int&lt;/span> i &lt;span style="color:#5bc4bf">=&lt;/span> indexFor&lt;span style="color:#5bc4bf">(&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hash&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span> newCapacity&lt;span style="color:#5bc4bf">);&lt;/span>&lt;span style="color:#776e71">//获取扩容后新的下标，可能跟原来一样，或者比原来的大newCapacity/2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> newTable&lt;span style="color:#5bc4bf">[&lt;/span>i&lt;span style="color:#5bc4bf">];&lt;/span>&lt;span style="color:#776e71">//设置当前元素在链表的下一个元素为新哈希表对应位置原来的元素，也就是说旧元素会被往后推，该链表上最早读取的元素会成为尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> newTable&lt;span style="color:#5bc4bf">[&lt;/span>i&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> e&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//哈希表的入口改为当前元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> e &lt;span style="color:#5bc4bf">=&lt;/span> next&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//遍历原来链表的下一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span> &lt;span style="color:#815ba4">while&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>e &lt;span style="color:#5bc4bf">!=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>工作原理在上面代码的注释里说得比较清楚了，值得注意的是，&lt;code>transfer(newTable)&lt;/code>之后的新哈希表里，每个链表的顺序都与扩容之前的刚好相反，这一点直接注定了会出现多线程扩容Bug。&lt;/p>
&lt;h3 id="扩容时的多线程死循环bug">扩容时的多线程死循环Bug&lt;/h3>
&lt;p>如上面的分析，由于扩容后每个链表的顺序都调转了，因此定性地分析，多线程同时触发扩容的时候，有可能其中一个线程已经把链表调转了，而另一个线程获取了链表调转前的状态，重新获取到时间片的时候，再次翻转，导致next引用的赋值出错，链表中构成环；这样在调用&lt;code>get()&lt;/code>方法的时候，进入到这个链表就会陷入死循环。
具体的举例分析，可以参考美团点评技术团队的文章 &lt;a class="link" href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener"
>Java 8系列之重新认识HashMap&lt;/a> ，在此贴出关键的部分：&lt;/p>
&lt;blockquote>
&lt;p>代码例子如下(便于理解，仍然使用JDK1.7的环境)：&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">HashMapInfiniteLoop&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> HashMap&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>Integer&lt;span style="color:#5bc4bf">,&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> map &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">new&lt;/span> HashMap&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>Integer&lt;span style="color:#5bc4bf">,&lt;/span>String&lt;span style="color:#5bc4bf">&amp;gt;(&lt;/span>2&lt;span style="color:#ef6155">，&lt;/span>0&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">75f&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">main&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String&lt;span style="color:#5bc4bf">[]&lt;/span> args&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>5&lt;span style="color:#ef6155">，&lt;/span> &lt;span style="color:#48b685">&amp;#34;C&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">new&lt;/span> Thread&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;Thread1&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">run&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>7&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#48b685">&amp;#34;B&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">out&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">println&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>map&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}.&lt;/span>&lt;span style="color:#06b6ef">start&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">new&lt;/span> Thread&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;Thread2&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#fec418">void&lt;/span> &lt;span style="color:#06b6ef">run&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>3&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#48b685">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">out&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">println&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>map&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}.&lt;/span>&lt;span style="color:#06b6ef">start&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。&lt;/p>
&lt;p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。&lt;br>
&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3.png"
width="1388"
height="628"
srcset="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3_hu8c609b8e724bfb2c0290ec31e1a358b7_20420_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/3_hu8c609b8e724bfb2c0290ec31e1a358b7_20420_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="530px"
>
注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。&lt;/p>
&lt;p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。&lt;br>
&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4.png"
width="1380"
height="522"
srcset="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4_hu4e735beccad0b142c011203082f64e5a_15190_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/4_hu4e735beccad0b142c011203082f64e5a_15190_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="264"
data-flex-basis="634px"
>&lt;br>
&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5.png"
width="1374"
height="484"
srcset="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5_hu2621d6ffff8728bce2c216db713e4324_15188_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/5_hu2621d6ffff8728bce2c216db713e4324_15188_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="283"
data-flex-basis="681px"
>&lt;br>
e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。&lt;br>
&lt;img src="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6.png"
width="1384"
height="482"
srcset="https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6_hufeb79b1a930dbfa7f169a79531429de5_14874_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/6_hufeb79b1a930dbfa7f169a79531429de5_14874_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="287"
data-flex-basis="689px"
>&lt;br>
于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。&lt;/p>
&lt;/blockquote>
&lt;h2 id="jdk8-如何修复多线程扩容bug">&lt;em>JDK8&lt;/em> 如何修复多线程扩容Bug&lt;/h2>
&lt;p>正如我在 &lt;a class="link" href="https://leibnizhu.github.io/2016/12/24/HashMap%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0/" >HashMap源码阅读笔记&lt;/a> 中分析到的，&lt;em>JDK8&lt;/em> 中&lt;code>Node&amp;lt;K,V&amp;gt;[] resize()&lt;/code>扩容方法利用了哈希表长度为2的幂，以及&lt;code>get()&lt;/code>方法对哈希值取低位的特性，结合每次扩容哈希表大小都增倍等特性，每次扩容，一个哈希桶里的元素在扩容后的位置，只会是原位置，或者原位置+原哈希表大小。&lt;br>
因此扩容的时候可以将一个哈希桶的扩容结果分为两个链表，还在原来位置的记为 &lt;em>低位链表&lt;/em>(我自己起的名字)，用&lt;code>loHead loTail&lt;/code>标记其头尾；扩容后分配到原位置+原哈希表大小的构成 &lt;em>高位链表&lt;/em>(同样是我自己起的名字)，用&lt;code>hiHead hiTail&lt;/code>标记其头尾。&lt;br>
具体实现的核心部分代码如下（省略了特殊容量处理、红黑树处理等等代码）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">final&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;[]&lt;/span> &lt;span style="color:#06b6ef">resize&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">/*…………省略前面代码…………*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>loHead&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>loTail&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//记录低位链表头尾位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>hiHead&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>hiTail&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//记录高位链表头尾位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>next&lt;span style="color:#5bc4bf">;&lt;/span>&lt;span style="color:#776e71">//记录当前链表元素在原来链表中的下一个元素，便于下次循环使用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">//遍历哈希桶的链表，拆分成高位和低位链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">do&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hash&lt;/span>&lt;span style="color:#5bc4bf">&amp;amp;&lt;/span>oldCap&lt;span style="color:#5bc4bf">)==&lt;/span>0&lt;span style="color:#5bc4bf">){&lt;/span> &lt;span style="color:#776e71">//新增的有效哈希位为0，即当前元素扩容后分配到 低位链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>loTail&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#776e71">//低位链表尚未初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> loHead&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//设置低位链表头部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//低位链表尾部增加当前元素，以保持原链表顺序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> loTail&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//更新低位链表的尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">else&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span> &lt;span style="color:#776e71">//新增的有效哈希位为1，即当前元素扩容后分配到 高位链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>hiTail&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#776e71">//高低位链表尚未初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> hiHead&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//设置高位链表头部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//高位链表尾部增加当前元素，以保持原链表顺序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> hiTail&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//更新高位链表的尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">while&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">=&lt;/span>next&lt;span style="color:#5bc4bf">)!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">//更新两个链表到哈希表中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>loTail&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span> &lt;span style="color:#776e71">//扩容后低位链表不为空，需要处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> loTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//低位链表设置尾部结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">]=&lt;/span>loHead&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//哈希桶设置链表入口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>hiTail&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span> &lt;span style="color:#776e71">//扩容后高位链表不为空，需要处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> hiTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//高位链表设置尾部结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">+&lt;/span>oldCap&lt;span style="color:#5bc4bf">]=&lt;/span>hiHead&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">//哈希桶设置链表入口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">/*…………省略后面代码…………*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体处理的过程我在上面的注释里说得比较清楚了，包括代码之前的那段文字。&lt;br>
可以看到，扩容后，原来哈希桶的链表被拆分为两个，两个链表中的元素都能继续维持原有的顺序。这样就算在多线程环境下同时扩容，一个线程A读取链表状态后停止工作，另一个线程B对同一链表的前几个元素进行扩容分成两个链表，此时线程A恢复工作，由于线程B对链表元素的顺序没有发生变化，所以线程A恢复工作后只是重复了拆分链表的工作，而不会因为链表已被改变顺序而导致环的生成，因此不会发生死循环的问题。&lt;br>
也就是说 &lt;em>JDK8&lt;/em> 的&lt;code>HashMap&lt;/code>扩容方法不但效率提升了（根据哈希值特点拆分链表，红黑树），而且还维持了扩容前后的链表顺序，从而解决了多线程扩容使链表产生环，导致死循环的问题。&lt;/p>
&lt;h2 id="其他线程安全map">其他线程安全Map&lt;/h2>
&lt;h3 id="hashtable类">Hashtable类&lt;/h3>
&lt;p>类名叫&lt;code>Hashtable&lt;/code>不叫&lt;code>HashTable&lt;/code>真是逼死强迫症。这个类现在很少用了，从源码可以看到，它是在&lt;code>get() put()&lt;/code>等方法的声明里加了&lt;code>synchronized&lt;/code>关键字来实现多线程安全的，因此显然效率比较低。&lt;/p>
&lt;h3 id="collectionssynchronizedmap方法">Collections.synchronizedMap()方法&lt;/h3>
&lt;p>在&lt;code>Collections&lt;/code>工具类里有&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#06b6ef">synchronizedMap&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> m&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>方法，传入将普通的Map实例，返回一个线程安全的Map实例。实现方法也比较简单，返回的是&lt;code>Collections&lt;/code>的内部类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">class&lt;/span> &lt;span style="color:#fec418">SynchronizedMap&lt;/span>&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> &lt;span style="color:#815ba4">implements&lt;/span> Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;,&lt;/span> Serializable &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> m&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">// Backing Map
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> Object mutex&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">// Object on which to synchronize
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SynchronizedMap&lt;span style="color:#5bc4bf">(&lt;/span>Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> m&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">m&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> Objects&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">requireNonNull&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>m&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutex &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SynchronizedMap&lt;span style="color:#5bc4bf">(&lt;/span>Map&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> m&lt;span style="color:#5bc4bf">,&lt;/span> Object mutex&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">m&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> m&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">mutex&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> mutex&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> V &lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object key&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">synchronized&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>mutex&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>&lt;span style="color:#815ba4">return&lt;/span> m&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">get&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>key&lt;span style="color:#5bc4bf">);}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">public&lt;/span> V &lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>K key&lt;span style="color:#5bc4bf">,&lt;/span> V value&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">synchronized&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>mutex&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>&lt;span style="color:#815ba4">return&lt;/span> m&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">put&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>key&lt;span style="color:#5bc4bf">,&lt;/span> value&lt;span style="color:#5bc4bf">);}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">/*………省略其他方法，大同小异………*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>的实例。上面也给出了简要的类代码，实现的方法相当简单粗暴，由构造方法传入线程不安全的类实例，用一个锁（默认是自身，也可以在构造方法里传入），在各种&lt;code>Map&lt;/code>接口的方法里面使用这个锁对线程不安全的类实例方法进行同步，也就是一个包装的设计模式，用同步代码块包装原有方法。&lt;br>
显然这样得到的线程安全类的效率也不高。&lt;/p>
&lt;h3 id="concurrenthashmap类">ConcurrentHashMap类&lt;/h3>
&lt;p>&lt;em>JDK8&lt;/em> 之前的&lt;code>ConcurrentHashMap&lt;/code>使用Segment（锁段）提高同步的效率，而 &lt;em>JDK8&lt;/em> 开始利用CAS算法大大提高了实现线程安全的效率。有空要再写一篇博客分析一下&lt;code>ConcurrentHashMap&lt;/code>的源码。&lt;/p></description></item><item><title>HashMap源码阅读笔记</title><link>https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 24 Dec 2016 16:48:04 +0800</pubDate><guid>https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid><description>&lt;h1 id="put方法">put方法：&lt;/h1>
&lt;p>put方法调用私有方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>putVal&lt;span style="color:#5bc4bf">(&lt;/span>hash&lt;span style="color:#5bc4bf">(&lt;/span>key&lt;span style="color:#5bc4bf">),&lt;/span>key&lt;span style="color:#5bc4bf">,&lt;/span>value&lt;span style="color:#5bc4bf">,&lt;/span>&lt;span style="color:#815ba4">false&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>&lt;span style="color:#815ba4">true&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="先去计算hash">先去计算hash。&lt;/h2>
&lt;p>key非空的时候返回：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>h&lt;span style="color:#5bc4bf">=&lt;/span>key&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hashCode&lt;/span>&lt;span style="color:#5bc4bf">())^(&lt;/span>h&lt;span style="color:#5bc4bf">&amp;gt;&amp;gt;&amp;gt;&lt;/span>16&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>即高16位不变，低16位与高16位做异或运算，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;amp;位操作，而非%求余)：(n - 1) &amp;amp; hash 。设计者认为这方法很容易发生碰撞。在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。因此，综合考虑了速度、作用、质量，把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。&lt;/p>
&lt;h2 id="然后进入putval">然后进入putVal()。&lt;/h2>
&lt;p>首先判断table是否为空（null或长度为0），为空的话进行resize()。&lt;/p>
&lt;h2 id="resize">resize()&lt;/h2>
&lt;p>如果原来table大小已经超过上限，则不resize，直接返回原来table；
原来table大小不为0且未超上限则容量增倍，threshold（扩容阈值）也增倍；
原来table大小为0，则大小设为DEFAULT_INITIAL_CAPACITY=16，threshold设为DEFAULT_LOAD_FACTOR*DEFAULT_INITIAL_CAPACITY=12。
然后按新的table大小，new一个Node数组。此时如果旧的table不为空，则需要进行原有数据的转移。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>oldTab&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">for&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>intj&lt;span style="color:#5bc4bf">=&lt;/span>0&lt;span style="color:#5bc4bf">;&lt;/span>j&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>oldCap&lt;span style="color:#5bc4bf">;++&lt;/span>j&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">=&lt;/span>oldTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">])!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> oldTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">]=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hash&lt;/span>&lt;span style="color:#5bc4bf">&amp;amp;(&lt;/span>newCap&lt;span style="color:#5bc4bf">-&lt;/span>1&lt;span style="color:#5bc4bf">)]=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elseif&lt;span style="color:#5bc4bf">(&lt;/span>e &lt;span style="color:#815ba4">instanceof&lt;/span> TreeNode&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">((&lt;/span>TreeNode&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;)&lt;/span>e&lt;span style="color:#5bc4bf">).&lt;/span>&lt;span style="color:#06b6ef">split&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>newTab&lt;span style="color:#5bc4bf">,&lt;/span>j&lt;span style="color:#5bc4bf">,&lt;/span>oldCap&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">else&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span>&lt;span style="color:#776e71">//preserveorder
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>loHead&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>loTail&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>hiHead&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span>hiTail&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#5bc4bf">&amp;lt;&lt;/span>K&lt;span style="color:#5bc4bf">,&lt;/span>V&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span>next&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">do&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">hash&lt;/span>&lt;span style="color:#5bc4bf">&amp;amp;&lt;/span>oldCap&lt;span style="color:#5bc4bf">)==&lt;/span>0&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>loTail&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loHead&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loTail&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">else&lt;/span>&lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>hiTail&lt;span style="color:#5bc4bf">==&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiHead&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiTail&lt;span style="color:#5bc4bf">=&lt;/span>e&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>&lt;span style="color:#815ba4">while&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>e&lt;span style="color:#5bc4bf">=&lt;/span>next&lt;span style="color:#5bc4bf">)!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>loTail&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">]=&lt;/span>loHead&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>hiTail&lt;span style="color:#5bc4bf">!=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hiTail&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">next&lt;/span>&lt;span style="color:#5bc4bf">=&lt;/span>&lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newTab&lt;span style="color:#5bc4bf">[&lt;/span>j&lt;span style="color:#5bc4bf">+&lt;/span>oldCap&lt;span style="color:#5bc4bf">]=&lt;/span>hiHead&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>大致意思就是遍历旧表的元素：
1.如果旧表元素的next为空（没有发生冲突而放入链表），则计算hash放进新表对应位置：newTab[旧表元素.hash&amp;amp;(newCap-1)]=旧表元素（newCap为新的table长度）;
2.若旧表元素为TreeNode实例，即该节点使用了红黑树进行存储的（JDK8开始引入），则执行split方法去处理；
3.否则遍历旧表元素的对应链表，重新计算位置。
resize的时候，因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂（oldCap）的位置，例如我们从16扩展为32时，具体的变化如下所示：
&lt;img src="https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1.png"
width="727"
height="67"
srcset="https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1_hu30e718e41d0f537c7be0bcca5730372d_7396_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1_hu30e718e41d0f537c7be0bcca5730372d_7396_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1085"
data-flex-basis="2604px"
>
因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色，0或1)。
因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了（通过&lt;code>(e.hash&amp;amp;oldCap)==0&lt;/code>进行判断），是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：
&lt;img src="https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2.png"
width="621"
height="353"
srcset="https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2_hu9b25c08baa945f3801d9bb9649882515_11884_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2_hu9b25c08baa945f3801d9bb9649882515_11884_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="422px"
>
既省去了重新计算hash值的时间，而且由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。
上面代码中else{//preserveorder之后的部分即完成了上述过程，将一个节点上的链表拆分成用loHead,loTail和hiHead,hiTail
描述的两个链表，分别对应新表中位置不变的节点，和移动oldCap之后的节点。&lt;/p>
&lt;h2 id="新建节点或更新value">新建节点或更新value&lt;/h2>
&lt;p>然后判断当前hash值对应table的节点是否为空，为空的话直接新建节点即可：new Node&amp;lt;&amp;gt;(hash,key,value,null);最后一个参数是next，因为table原节点为空，为链表第一个元素，所以next设为null即可；
如果hash值对应table节点不为空，则判断原节点和当前插入的数据key及value是否都一致，如果一致，证明是同一个节点，无需重新插入；
否则进入table节点的链表，遍历，如果找到与待插入节点一样的节点，则直接退出，否则一直找到链表末端节点还没找到相同的，则增加新节点插入当前数据，如果当前链表长度大于TREEIFY_THRESHOLD-1，还需要进行treeifyBin()操作，将链表转换为红黑树，提高查询效率（O(n)变为O(logn)，JDK8之后引入的优化）。
如果以上操作中找到待插入节点的key在map中已存在，则用新数据覆盖之，最后size++, 判断table尺寸，看是否需要进行resize()。&lt;/p>
&lt;h1 id="get方法">get方法：&lt;/h1>
&lt;p>get时调用&lt;code>getNode(int hash, Object key)&lt;/code>方法。
首先table为null或长度为0或对应hash位置的元素为null均返回null。
否则先判断hash位置上的元素key和get方法的key相同，如果相同则直接返回hash位置的元素；否则判断hash位置节点是否为TreeNode，若是则调用getTreeNode方法进行处理并返回；对于非TreeNode节点，且hash位置节点的key不等于get方法dekey的话，则遍历hash位置节点的链表，直到找到key相同的节点并返回节点的value。&lt;/p></description></item></channel></rss>