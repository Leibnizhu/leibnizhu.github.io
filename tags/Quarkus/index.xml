<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quarkus on Heaven's Door</title><link>https://leibnizhu.github.io/tags/Quarkus/</link><description>Recent content in Quarkus on Heaven's Door</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 15 May 2022 16:03:10 +0800</lastBuildDate><atom:link href="https://leibnizhu.github.io/tags/Quarkus/index.xml" rel="self" type="application/rss+xml"/><item><title>关于Quarkus的碎碎念</title><link>https://leibnizhu.github.io/p/%E5%85%B3%E4%BA%8EQuarkus%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</link><pubDate>Sun, 15 May 2022 16:03:10 +0800</pubDate><guid>https://leibnizhu.github.io/p/%E5%85%B3%E4%BA%8EQuarkus%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</guid><description>&lt;img src="https://leibnizhu.github.io/p/%E5%85%B3%E4%BA%8EQuarkus%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/thumbnail.jpg" alt="Featured image of post 关于Quarkus的碎碎念" />&lt;p>最近把一个老项目迁到了Quarkus，想谈谈一些感想和想-法。&lt;/p>
&lt;h2 id="why-quarkus">Why Quarkus???&lt;/h2>
&lt;p>答案很简单，for 云原生。在 &lt;a class="link" href="https://quarkus.io/" target="_blank" rel="noopener"
>官网&lt;/a> 也可以看到Quarkus的宣传点也是围绕云原生进行的。&lt;br>
云原生的实现大概有这些要点：&lt;/p>
&lt;ol>
&lt;li>应用/架构设计遵循 &lt;a class="link" href="https://12factor.net/" target="_blank" rel="noopener"
>12-Factor&lt;/a>&lt;/li>
&lt;li>服务容器化，最好框架层面就有支持&lt;/li>
&lt;li>启动速度快，资源占用少，便于伸缩。这里又包括镜像大小、layer设计、应用本身启动速度等因素。&lt;/li>
&lt;li>配合GitOps持续集成、持续交付&lt;/li>
&lt;/ol>
&lt;p>而Quarkus很好解决了这些问题。反观Spring，在启动速度、资源占用这块实在不尽人意，对k8s的支持也是很落后，对graalvm native- image也是起步落后。&lt;/p>
&lt;h2 id="用不用native-">用不用Native？？-&lt;/h2>
&lt;p>谈Quarkus绕不开native（native可执行文件的构建）。没办法，官方先来的，首页就是大大的native/jvm性能对比。&lt;br>
native实测是真的快（不到0.1s），内存占用也确实小（启动几十MB，跑一段时间稳定大概300MB附近，不过不同压力的不同类型服务也不能说明什么）。但有什么缺点？&lt;/p>
&lt;ol>
&lt;li>&lt;strong>编译速度慢&lt;/strong> ：一个比较简单的web服务，在我们CICD的机器上编译大概需要4min，如果是容器内multistage编译则时间更长，但直接编译对环境又有要求，所以还是最好有更强大的编译机器。&lt;/li>
&lt;li>&lt;strong>编译产物体积大&lt;/strong> ：我们编译出来的二进制文件大约130-150MB，&lt;code>upx&lt;/code> 压缩后40MB以内；单看最后的docker镜像，如果用最小的基础镜像，大约整个镜像可以做到100MB以内，是挺小的；但是每次构建变更的layer，都是整个二进制文件的变更，也就是没次编译多了一个40MB的layer出来，体积相当可观。同样的服务，如果打jar，真正变更的只有不到1MB，pod拉镜像的速度会更快，对docker仓库的压力也更小。&lt;/li>
&lt;li>&lt;strong>开发多了不少限制&lt;/strong> ：你要注意新引入的依赖是不是支持native的；所以可能需要json序列化反序列化的类记得加上 &lt;code>@RegisterForReflection&lt;/code> 注解；如果是外部依赖的实体类，要编写一个什么json文件声明要处理…………本文不是Quarkus教程，就不详细展开了，总之，如果要native，最好整个服务都只用quarkus生态里面的依赖，否则你不知道什么时候就编译不了了。虽然quarkus的生态已经比较完善，但总有没cover到的地方，比如hadoop生态的sdk。&lt;/li>
&lt;/ol>
&lt;p>没错，我们quarkus native上了生产一两个月，运行良好，充分体现了native的优越性；但是，现在要加入hadoop这些，没办法，只能放弃，要么自己实现一整套hdfs client之类的，成本很高。&lt;/p>
&lt;h2 id="响应式要上吗">响应式要上吗？&lt;/h2>
&lt;p>官网说：&lt;/p>
&lt;blockquote>
&lt;p>Unifies imperative and reactive
Combine both the familiar imperative code and the reactive style when developing applications.&lt;/p>
&lt;/blockquote>
&lt;p>真的有那么Unify吗？未必哦。&lt;br>
这里说的 &lt;code>Unifies imperative and reactive&lt;/code> 是指：&lt;/p>
&lt;ul>
&lt;li>Quarkus core基于Vert.X实现，是响应式的，这也是它能unify命令式和响应式的关键原因，也是各个扩展能自行选择命令式实现和响应式实现的原因&lt;/li>
&lt;li>Quarkus在Vert.X基础上做了一个路由层来兼容两种实现，像HTTP请求这种直接通过路由层、如果是响应式代码，直接在I/O线程上执行；命令式代码则丢到Worker线程执行（就要做上下文切换了）；至于Quarkus怎么知道是什么实现，就看方法注解以及签名了，具体不展开&lt;/li>
&lt;li>也就是说，至少在http接口这一层面，开发者可以选择用命令式还是响应式编程实现，另外定时任务、Eventbus之类也是支持的&lt;/li>
&lt;li>但到了ORM层只能有一个选择，是的， &lt;code>Hibernate&lt;/code> 和 &lt;code>Hibernate-reactive&lt;/code> 显然不能共存。&lt;/li>
&lt;/ul>
&lt;p>如果选了 &lt;code>Hibernate-reactive&lt;/code> 那么意味你的dao都是返回Uni或Multi，这会一直传递出去（除非await结果）。&lt;br>
另外，像 &lt;code>resteasy&lt;/code> 用了reative的话，filter这些在I/O线程运行，不能阻塞，如果里面用到redis client之类也要改Reactive RedisClient。&lt;br>
总而言之，选了Reactive，多少是有 &lt;strong>传递性&lt;/strong> 的，很多地方要跟着改。&lt;br>
在我们的项目里，也开了个分支彻底改了Reactive，发现在一些地方支持还不是很好，比如 ：&lt;/p>
&lt;ul>
&lt;li>@Scheduler 方法里面开Panache的多表事务会报错&lt;/li>
&lt;li>&lt;code>Hibernate-reactive&lt;/code> 不支持 OneToMany ManyToOne 等的懒加载，必须在HQL用 &lt;code>join fetch&lt;/code> 声明拉外表（就不是lazy了）&lt;/li>
&lt;li>………………&lt;/li>
&lt;/ul>
&lt;p>最后，基于以下考虑，放弃了reactive：&lt;/p>
&lt;ol>
&lt;li>老代码迁移，不可能dao全部改reactive，况且dao层还会往外传递reactive&lt;/li>
&lt;li>quarkus reactive 本身限制，比如上面列的一些点&lt;/li>
&lt;li>团队接受、理解Reactive的成本&lt;/li>
&lt;li>&lt;a class="link" href="https://openjdk.java.net/jeps/425" target="_blank" rel="noopener"
>virtual thread&lt;/a> 已经进入 jdk19 preview了，到下个LTS，jdk21，quarkus应该已经跟进支持，到时切过去就是。&lt;/li>
&lt;/ol>
&lt;p>从长远来看，趋势应该是开发者只要写同步代码，不用管实际执行，通过虚拟线程压榨线程性能，大部分需求不需要在代码层面通过类似reactive这样的pattern提高性能。&lt;br>
不过话说回来，reactive也不只是为了压榨线程性能，具体就不展开了。&lt;br>
&lt;strong>有一说一，Quarkus 的 mutiny对比RxJava之类，好用不是一点两点，接口设计相当优秀，值得学习&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>未完待续&lt;/p>
&lt;/blockquote></description></item></channel></rss>