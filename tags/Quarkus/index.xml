<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quarkus on Heaven's Door</title><link>https://leibnizhu.github.io/tags/Quarkus/</link><description>Recent content in Quarkus on Heaven's Door</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 28 Jul 2023 12:11:44 +0800</lastBuildDate><atom:link href="https://leibnizhu.github.io/tags/Quarkus/index.xml" rel="self" type="application/rss+xml"/><item><title>升级Quarkus3备忘录</title><link>https://leibnizhu.github.io/p/%E5%8D%87%E7%BA%A7Quarkus3%E5%A4%87%E5%BF%98%E5%BD%95/</link><pubDate>Fri, 28 Jul 2023 12:11:44 +0800</pubDate><guid>https://leibnizhu.github.io/p/%E5%8D%87%E7%BA%A7Quarkus3%E5%A4%87%E5%BF%98%E5%BD%95/</guid><description>&lt;img src="https://leibnizhu.github.io/p/%E5%8D%87%E7%BA%A7Quarkus3%E5%A4%87%E5%BF%98%E5%BD%95/zelda.png" alt="Featured image of post 升级Quarkus3备忘录" />&lt;p>Quarkus3已经发布一段时间了（&lt;a class="link" href="https://cn.quarkus.io/blog/quarkus-3-0-final-released/" target="_blank" rel="noopener"
>Quarkus 3.0, our new major release, is here! April 26, 2023&lt;/a>），不知道大家都升级了没有。&lt;br>
而Quarkus3.2也成为了首个LTS版本（&lt;a class="link" href="https://quarkus.io/blog/lts-releases/" target="_blank" rel="noopener"
>Long-Term Support (LTS) for Quarkus&lt;/a>），很适合升级。&lt;br>
官方给出了升级的方法，如：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.0" target="_blank" rel="noopener"
>Migration Guide 3.0&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.0:-Hibernate-ORM-5-to-6-migration" target="_blank" rel="noopener"
>Migration Guide 3.0: Hibernate ORM 5 to 6 migration&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.1" target="_blank" rel="noopener"
>Migration Guide 3.1&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.2" target="_blank" rel="noopener"
>Migration Guide 3.2&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>但实际升级下来，除了官方Migration Guide以外，还有一些其他的必要的调整，如第三方插件，在此记录。&lt;/p>
&lt;ol>
&lt;li>&lt;code>kubernetes-client&lt;/code> 系列依赖从6.3升级到6.7，部分api不兼容；因此要检查pom文件，确认是否有显式声明的依赖版本和 &lt;code>quarkus-bom&lt;/code> 所定义的版本冲突；其他的依赖类似的，比如 &lt;code>quarkus-bom&lt;/code> 声明了一个依赖A及其子依赖B的版本，而在项目中显式声明了依赖A的版本，则其B与A可能不兼容&lt;/li>
&lt;li>如果测试中使用到h2数据库，需要在jdbcUrl加上 &lt;code>DATABASE_TO_UPPER=false&lt;/code> 以避免一些sql语句失败；h2变成默认区分大小写了，具体原因未知&lt;/li>
&lt;li>javax转jakarta包这点是官方Migration Guide里面有写的，但要注意配置文件里如果用到也记得修改。如restclient的scope配置&lt;/li>
&lt;li>如果使用到lombok，建议升级到最新版，并需要在 &lt;code>maven-compiler-plugin&lt;/code> 插件加上：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">&amp;lt;configuration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">&amp;lt;annotationProcessorPaths&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">&amp;lt;path&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">&amp;lt;groupId&amp;gt;&lt;/span>org.projectlombok&lt;span style="color:#5bc4bf">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">&amp;lt;artifactId&amp;gt;&lt;/span>lombok&lt;span style="color:#5bc4bf">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">&amp;lt;version&amp;gt;&lt;/span>${lombok.version}&lt;span style="color:#5bc4bf">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">&amp;lt;/path&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">&amp;lt;/annotationProcessorPaths&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">&amp;lt;/configuration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>一些插件依赖的升级：
&lt;ul>
&lt;li>quarkus-logging-logback=1.1.0&lt;/li>
&lt;li>logback-core=1.4.7&lt;/li>
&lt;li>quarkus-mybatis-plus=2.0.0&lt;/li>
&lt;li>quarkus-openapi-generator=2.2.8&lt;/li>
&lt;li>mockito-inline=5.2.0&lt;/li>
&lt;li>显式增加 quarkus-rest-client-jackson 依赖（quarkus3不绑定在 quarkus-rest-client 里面了）&lt;/li>
&lt;li>openapi-generator-maven-plugin 升级6.6.0，并加上 &lt;code>&amp;lt;useJakartaEe&amp;gt;true&amp;lt;/useJakartaEe&amp;gt;&lt;/code> 配置，这样生成的代码的import才是使用jakarta包的；但升级后，model前缀的替换出现问题，如果不使用 &lt;code>modelNamePrefix + importMappings&lt;/code> 配置则无影响&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果使用到spotless，注意检查import顺序是否加上了jakarta包&lt;/li>
&lt;li>Hibernate升级带来的一些调整；
&lt;ul>
&lt;li>hql语句必须用实体的属性名，需要检查&lt;/li>
&lt;li>hql语句对类型的检查更为严格，需要检查&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>由于Quarkus3使用的 &lt;code>Resteasy&lt;/code> 升级到6.x（升级Jakarta REST3），所以如果你的应用使用到Skywalking进行监控，则原来的Resteasy4.x插件无法正常工作：
&lt;ul>
&lt;li>为此我写了Skywalking javaagent的Resteasy 6.x plugin&lt;/li>
&lt;li>该PR &lt;a class="link" href="https://github.com/apache/skywalking-java/pull/587" target="_blank" rel="noopener"
>Add support for RESTEasy 6.x #587&lt;/a> 已合入主分支&lt;/li>
&lt;li>该特性随Skywalking javaagent 9.0.0版本发布，预估最早8月底发布：&lt;img src="https://leibnizhu.github.io/p/%E5%8D%87%E7%BA%A7Quarkus3%E5%A4%87%E5%BF%98%E5%BD%95/skw9.png"
width="1834"
height="642"
srcset="https://leibnizhu.github.io/p/%E5%8D%87%E7%BA%A7Quarkus3%E5%A4%87%E5%BF%98%E5%BD%95/skw9_hu4dff89fbeb87127e2d9147e6535d98ab_128230_480x0_resize_box_3.png 480w, https://leibnizhu.github.io/p/%E5%8D%87%E7%BA%A7Quarkus3%E5%A4%87%E5%BF%98%E5%BD%95/skw9_hu4dff89fbeb87127e2d9147e6535d98ab_128230_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="285"
data-flex-basis="685px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Quarkus RestClient路径参数URL编码问题</title><link>https://leibnizhu.github.io/p/Quarkus-RestClient%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0URL%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 10 Mar 2023 13:17:21 +0800</pubDate><guid>https://leibnizhu.github.io/p/Quarkus-RestClient%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0URL%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</guid><description>&lt;img src="https://leibnizhu.github.io/p/Quarkus-RestClient%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0URL%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/thumbnail.jpg" alt="Featured image of post Quarkus RestClient路径参数URL编码问题" />&lt;p>问题比较简单，简单记录下。&lt;/p>
&lt;p>当我们在Quarkus中使用他的 &lt;a class="link" href="https://cn.quarkus.io/guides/rest-client" target="_blank" rel="noopener"
>RestClient&lt;/a>，恩其实主要是用RestEasy client，声明了一个带路径参数的API，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">@Path&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;/path&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">@RegisterRestClient&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">interface&lt;/span> &lt;span style="color:#fec418">SomeApi&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">@GET&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">@Path&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;/to/{id}&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#06b6ef">getSomething&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#5bc4bf">@PathParam&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> String id&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果路径参数的取值带有 &lt;code>&amp;quot;/&amp;quot;&lt;/code> ，而该服务要求对这种参数进行URL编码，以免被其他endpoint接收，这时候会发现，如果传入未URL编码的id，如 &lt;code>&amp;quot;aaa/bbb&amp;quot;&lt;/code>，实际发出的请求为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>GET /path/to/aaa/bbb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时该API可能无法正常工作（比如，有另一个 &lt;code>&amp;quot;/path/to/{id}/bbb&amp;quot;&lt;/code> 的接口）。如果传入已URL编码的id，如 &lt;code>&amp;quot;aaa％2Fbbb&amp;quot;&lt;/code>，实际发出的请求为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>GET /path/to/aaa%252Fbbb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里是RestEasy client将 &lt;code>%&lt;/code> 字符进行了URL编码变成 &lt;code>%25&lt;/code>，而 &lt;code>2F&lt;/code> 当作普通字符未处理。而该API要求传入 &lt;code>GET /path/to/aaa%2Fbbb&lt;/code> 才能正常工作。&lt;/p>
&lt;p>因为在quarkus的github中没搜到相关issue，所以直接看代码。&lt;/p>
&lt;p>经过调试，发现 &lt;code>RestClient&lt;/code> 是在 &lt;code>org.jboss.resteasy.client.jaxrs.internal.proxy.processors.ProcessorFactory#createProcessor()&lt;/code> 方法对路径参数进行处理的创建 &lt;code>PathParamProcessor&lt;/code> 实例的，具体过程：&lt;/p>
&lt;ol>
&lt;li>&lt;code>ProcessorFactory#createProcessor&lt;/code> 根据 &lt;code>@PathParam&lt;/code> 注解创建 &lt;code>PathParamProcessor&lt;/code> 实例，如果同时还有 &lt;code>@Encoded&lt;/code> 注解控制是否URL编码&lt;/li>
&lt;li>&lt;code>org.jboss.resteasy.client.jaxrs.internal.proxy.processors.webtarget.PathParamProcessor#build&lt;/code> 方法创建 &lt;code>ResteasyWebTarget&lt;/code> 实例&lt;/li>
&lt;li>&lt;code>PathParamProcessor#build&lt;/code> 方法里面会调用 &lt;code>org.jboss.resteasy.specimpl.ResteasyUriBuilderImpl#resolveTemplate()&lt;/code> 方法创建 &lt;code>UriBuilder&lt;/code> 实例，这里会调用 &lt;code>ResteasyUriBuilderImpl#replaceParameter&lt;/code> 方法将实际传入参数构建uri&lt;/li>
&lt;li>&lt;code>replaceParameter&lt;/code> 方法先从调用的参数Map获取当前要替换的参数，如果需要对 &lt;code>'/'&lt;/code> 编码，也就是说有 &lt;code>@Encoded&lt;/code> 注解，则调用 &lt;code>org.jboss.resteasy.util.Encode.encodePathSegmentAsIs&lt;/code> 方法进行编码，否则使用 &lt;code>org.jboss.resteasy.util.Encode#encodePathAsIs&lt;/code> 进行编码。&lt;/li>
&lt;li>&lt;code>encodePathSegmentAsIs&lt;/code> 和 &lt;code>Encode#encodePathAsIs&lt;/code> 方法最终都是调用 &lt;code>Encode#encodeFromArray&lt;/code>方法，区别在于传入的编码Map，前者传入 &lt;code>pathEncoding&lt;/code>，后者传入 &lt;code>pathSegmentEncoding&lt;/code>；&lt;/li>
&lt;li>在 &lt;code>Encode&lt;/code> 的静态代码块里，对 &lt;code>pathEncoding&lt;/code> 和 &lt;code>pathSegmentEncoding&lt;/code> 进行初始化，其中 &lt;code>pathEncoding&lt;/code> 没有 &amp;lsquo;/&amp;rsquo; 的映射，而 &lt;code>pathSegmentEncoding&lt;/code> 特意加入 &amp;lsquo;/&amp;rsquo; 的映射，具体如下：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> String&lt;span style="color:#5bc4bf">[]&lt;/span> pathEncoding &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">new&lt;/span> String&lt;span style="color:#5bc4bf">[&lt;/span>128&lt;span style="color:#5bc4bf">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> String&lt;span style="color:#5bc4bf">[]&lt;/span> pathSegmentEncoding &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#815ba4">new&lt;/span> String&lt;span style="color:#5bc4bf">[&lt;/span>128&lt;span style="color:#5bc4bf">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">static&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">for&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> i &lt;span style="color:#5bc4bf">=&lt;/span> 0&lt;span style="color:#5bc4bf">;&lt;/span> i &lt;span style="color:#5bc4bf">&amp;lt;&lt;/span> 128&lt;span style="color:#5bc4bf">;&lt;/span> i&lt;span style="color:#5bc4bf">++)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>i &lt;span style="color:#5bc4bf">&amp;gt;=&lt;/span> &lt;span style="color:#48b685">&amp;#39;a&amp;#39;&lt;/span> &lt;span style="color:#5bc4bf">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#5bc4bf">&amp;lt;=&lt;/span> &lt;span style="color:#48b685">&amp;#39;z&amp;#39;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#815ba4">continue&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>i &lt;span style="color:#5bc4bf">&amp;gt;=&lt;/span> &lt;span style="color:#48b685">&amp;#39;A&amp;#39;&lt;/span> &lt;span style="color:#5bc4bf">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#5bc4bf">&amp;lt;=&lt;/span> &lt;span style="color:#48b685">&amp;#39;Z&amp;#39;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#815ba4">continue&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>i &lt;span style="color:#5bc4bf">&amp;gt;=&lt;/span> &lt;span style="color:#48b685">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#5bc4bf">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#5bc4bf">&amp;lt;=&lt;/span> &lt;span style="color:#48b685">&amp;#39;9&amp;#39;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#815ba4">continue&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">switch&lt;/span> &lt;span style="color:#5bc4bf">((&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> i&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// …………………… 其他跳过的字符省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">case&lt;/span> &lt;span style="color:#48b685">&amp;#39;/&amp;#39;&lt;/span>&lt;span style="color:#5bc4bf">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">continue&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pathEncoding&lt;span style="color:#5bc4bf">[&lt;/span>i&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> encodeString&lt;span style="color:#5bc4bf">(&lt;/span>String&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">((&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> i&lt;span style="color:#5bc4bf">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pathEncoding&lt;span style="color:#5bc4bf">[&lt;/span>&lt;span style="color:#48b685">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#48b685">&amp;#34;%20&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// ……………………
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">arraycopy&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>pathEncoding&lt;span style="color:#5bc4bf">,&lt;/span> 0&lt;span style="color:#5bc4bf">,&lt;/span> pathSegmentEncoding&lt;span style="color:#5bc4bf">,&lt;/span> 0&lt;span style="color:#5bc4bf">,&lt;/span> pathEncoding&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">length&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pathSegmentEncoding&lt;span style="color:#5bc4bf">[&lt;/span>&lt;span style="color:#48b685">&amp;#39;/&amp;#39;&lt;/span>&lt;span style="color:#5bc4bf">]&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> &lt;span style="color:#48b685">&amp;#34;%2F&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// ……………………
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以达到了前面说的效果。&lt;/p>
&lt;p>根据代码分析，只要给路径参数加上 &lt;code>@Encoded&lt;/code> 注解即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">@Path&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;/path&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">@RegisterRestClient&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">interface&lt;/span> &lt;span style="color:#fec418">SomeApi&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">@GET&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">@Path&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;/to/{id}&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#06b6ef">getSomething&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#5bc4bf">@PathParam&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">@Encoded&lt;/span> String id&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>翻完代码，再想起来可以看看RestEasy的文档，发现其实有写的：&lt;a class="link" href="https://docs.jboss.org/resteasy/docs/4.7.7.Final/userguide/html/_Encoded_and_encoding.html" target="_blank" rel="noopener"
>RestEasy4.7.7.Final UserGuide Chapter 16. @Encoded and encoding&lt;/a> 。&lt;/p></description></item><item><title>Quarkus服务接入Skywalking链路跟踪</title><link>https://leibnizhu.github.io/p/Quarkus%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5Skywalking%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/</link><pubDate>Mon, 18 Jul 2022 12:58:35 +0800</pubDate><guid>https://leibnizhu.github.io/p/Quarkus%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5Skywalking%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/</guid><description>&lt;img src="https://leibnizhu.github.io/p/Quarkus%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5Skywalking%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/bus.jpg" alt="Featured image of post Quarkus服务接入Skywalking链路跟踪" />&lt;h2 id="quarkus对可观测性的支持情况">Quarkus对可观测性的支持情况&lt;/h2>
&lt;p>Quarkus在可观测性方面支持了 &lt;a class="link" href="https://opentracing.io/" target="_blank" rel="noopener"
>OpenTracing&lt;/a> 和 &lt;a class="link" href="https://opentelemetry.io/" target="_blank" rel="noopener"
>OpenTelemetry&lt;/a> 。如果要对使用Quarkus开发的服务接入Skywalking做链路跟踪：&lt;/p>
&lt;ul>
&lt;li>Skywalking支持OpenTelemetry，但只是在 &lt;a class="link" href="https://skywalking.apache.org/docs/main/latest/en/setup/backend/opentelemetry-receiver/" target="_blank" rel="noopener"
>metric部分&lt;/a> 支持了。至于为什么，可以看看PR &lt;a class="link" href="https://github.com/apache/skywalking/issues/7374" target="_blank" rel="noopener"
>What does opentelemetry mean?&lt;/a> 里面的讨(nu)论(chi)。&lt;/li>
&lt;li>Skywalking兼容Opentracing协议。但Quarkus目前对OpenTracing的支持是针对Jaeger的，而Skywalking是用GRpc通信的，不能直接对接。&lt;/li>
&lt;/ul>
&lt;p>所以摆在面前的路有两条：&lt;/p>
&lt;ol>
&lt;li>模仿 &lt;a class="link" href="https://github.com/smallrye/smallrye-opentracing" target="_blank" rel="noopener"
>quarkus-smallrye-opentracing&lt;/a> （已deprecated），基于Provider，写一套用于拦截Quarkus请求打span等的插件。&lt;/li>
&lt;li>使用Skywalking Java Agent 传统姿势，但要注意各个组件的支持情况。&lt;/li>
&lt;/ol>
&lt;p>第一条路工作量是未知的，可行性也未知。还是选简单点的第二条路吧。&lt;/p>
&lt;h2 id="skywalking对quarkus常用组件的支持情况">Skywalking对Quarkus常用组件的支持情况&lt;/h2>
&lt;p>先简单盘点一下Skywalking Java Agent对Quarkus做web服务常用组件的支持情况：&lt;/p>
&lt;ul>
&lt;li>core: 使用了 &lt;code>Vert.X-core&lt;/code>， 支持3.x 和 4.x。&lt;/li>
&lt;li>Http server: 使用了 &lt;code>RestEasy&lt;/code>， 已支持 3.x。Quarkus用的是 4.x&lt;/li>
&lt;li>Http client : RestClient，最终使用的是 &lt;code>Apache httpcomponent HttpClient&lt;/code> ，已支持。&lt;/li>
&lt;li>ORM:
&lt;ul>
&lt;li>&lt;code>Hibernate&lt;/code>：不支持。&lt;/li>
&lt;li>&lt;code>MyBatis&lt;/code>: 支持 3.4.x -&amp;gt; 3.5.x&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis: 使用了 &lt;code>vertx-redis&lt;/code>，Vertx是自己用NetSocket实现了redis的协议，目前还不支持。&lt;/li>
&lt;/ul>
&lt;p>可以看到，目前redis client、http Server、Hibernate还不支持。&lt;/p>
&lt;p>注：详细请参考官方的 &lt;a class="link" href="https://skywalking.apache.org/docs/skywalking-java/latest/en/setup/service-agent/java-agent/supported-list/" target="_blank" rel="noopener"
>支持列表&lt;/a> 。&lt;/p>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;h3 id="resteasy-4x">RestEasy 4.x&lt;/h3>
&lt;p>这个我提了 &lt;a class="link" href="https://github.com/apache/skywalking-java/pull/265" target="_blank" rel="noopener"
>PR&lt;/a>，已 &lt;a class="link" href="https://github.com/apache/skywalking-java/commit/a60a61b83de7d7daed1a4bb1d2953ce1bc3f4fa4" target="_blank" rel="noopener"
>合入main分支&lt;/a>，等8.12.0版本发布就行，或者先下载 &lt;a class="link" href="https://github.com/apache/skywalking-java/commits/main" target="_blank" rel="noopener"
>main分支源码&lt;/a>、自行打包用着。&lt;/p>
&lt;p>&lt;strong>2022-09-10更新&lt;/strong> 8.12.0 版本已经release：&lt;a class="link" href="https://github.com/apache/skywalking-java/releases/tag/v8.12.0" target="_blank" rel="noopener"
>Releases v8.12.0&lt;/a>，可直接使用&lt;/p>
&lt;p>在实操中，请移除掉 RestEasy 3.x 的插件，以免冲突。如在sidecar中执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rm /skywalking/agent/plugins/resteasy-server-3.x*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="hibernate">Hibernate&lt;/h3>
&lt;p>ORM虽然不支持 &lt;code>Hibernate&lt;/code>，但支持具体的jdbc驱动（如Mysql、PostgreSql等），其实是可以追踪到数据库读写的，只是少了ORM这一层而已，关系不大。&lt;/p>
&lt;h3 id="vertx相关">Vert.X相关&lt;/h3>
&lt;p>什么？Vert.X-core不是支持了吗？&lt;/p>
&lt;p>正因为支持了才有问题！&lt;/p>
&lt;h4 id="skywalking如何支持vertx的">Skywalking如何支持Vert.X的&lt;/h4>
&lt;p>我们可以先看看Skywalking的 &lt;a class="link" href="https://github.com/apache/skywalking-java/tree/main/apm-sniffer/apm-sdk-plugin/vertx-plugins/vertx-core-4.x-plugin" target="_blank" rel="noopener"
>&lt;code>vertx-core-4.x-plugin&lt;/code>&lt;/a> 源码，跟踪原理很简单，它对 &lt;code>VertxBuilder&lt;/code> 进行了增强，在VertxImpl实例化时注入了 &lt;code>SWVertxTracer&lt;/code> 作为Vertx的tracer，也就是说利用了vertx的tracer机制。&lt;/p>
&lt;p>这样做的原因很简单，Vertx大量用到了EventLoop线程和Worker线程的切换，如果直接像其他的Skywalking插件一样，直接增强处理的方法，那么调用 &lt;code>ContextManager.getOrCreate()&lt;/code> 的时候，由于线程切换，是拿不到上一个span使用的 &lt;code>TracerContext&lt;/code> （保存在ThreadLocal里）的，也就是每个操作都成了独立的TracerContext，那么就无法将span串起来，也就无法实现追踪。所以直接利用Vert.X自己提供的tracer机制，Vert.X各个组件在触发一些事件（如Http服务接受到请求，Http客户端接受到响应）时，就会调用 &lt;code>VertxTracer&lt;/code> 的对应方法，记录事件，在这个过程中，Vertx是允许带一个Payload的，对于 &lt;code>vertx-core-4.x-plugin&lt;/code> 插件，这个Payload就是 Skywalking的 &lt;code>AbstractSpan&lt;/code> ，这样就可以在Vert.X内部实现绕开ThreadLocal的线程限制、进行追踪了。&lt;/p>
&lt;h4 id="skywalking对vertx的支持与quarkus的关系">Skywalking对Vert.X的支持、与Quarkus的关系&lt;/h4>
&lt;p>那么问题在哪呢？&lt;/p>
&lt;p>问题就在于，这样的机制决定了，只有在Vert.X体系里的才会被追踪到，看看前面列的那些组件，RestEasy、HttpClient、JDBC Driver这些都不在Vert.X控制下的，他们产生的Span和Vert.X是无法关联起来的。&lt;/p>
&lt;p>我们再看看目前 &lt;code>vertx-core-4.x-plugin&lt;/code> 实际支持的Vert.X组件，从 &lt;a class="link" href="https://github.com/apache/skywalking-java/blob/main/apm-sniffer/apm-sdk-plugin/vertx-plugins/vertx-core-4.x-plugin/src/main/java/org/apache/skywalking/apm/plugin/vertx4/SWVertxTracer.java" target="_blank" rel="noopener"
>源码&lt;/a> 来看，实际支持了HTTP服务、HTTP客户端，以及EventBus（包括本地的和分布式的）。&lt;/p>
&lt;p>一个个看：&lt;/p>
&lt;ul>
&lt;li>HTTP服务，Quarkus在Vert.X-core之上用了 &lt;code>RestEasy&lt;/code> 做路由，其实是无需再在Vert.X里面追踪的。&lt;/li>
&lt;li>HTTP客户端，前面说了，目前用的是 &lt;code>Apache httpcomponent HttpClient&lt;/code> ，也是不用管的。&lt;/li>
&lt;li>Eventbus，Quarkus确实用了Vert.X-core的EventBus，这个好像没啥办法&lt;/li>
&lt;li>Redis Client，目前 &lt;code>vertx-core-4.x-plugin&lt;/code> 不支持，Quarkus用到，有兴趣的朋友可以考虑实现一个、提个PR&lt;/li>
&lt;/ul>
&lt;p>问题捋完了，方案就是个取舍的问题了。&lt;/p>
&lt;ul>
&lt;li>艰难的道路——全面支持Vert.X
&lt;ul>
&lt;li>应用里的RestClient改成Vert.X的Http client&lt;/li>
&lt;li>扩展 &lt;code>vertx-core-4.x-plugin&lt;/code> ，增加Redis请求响应的处理&lt;/li>
&lt;li>考虑如何支持 JDBC Driver 的追踪&lt;/li>
&lt;li>对于Quarkus其他组件，随缘了，或者想办法把VertxTracer和正常的基于TreadLocal的TracerContext关联起来？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>世上无难事、只要肯放弃之路
&lt;ul>
&lt;li>排除掉 &lt;code>vertx-core-4.x-plugin&lt;/code> ，放弃EventBus和Redis Client的追踪&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>我选择放弃，在sidecar里面执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rm /skywalking/agent/plugins/apm-vertx-core-*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>RestEasy 4.x 将在Skywalking 8.12.0里面支持，如有需要可提前自行编译（&lt;strong>2022-09-10更新&lt;/strong> 2022-09-03已release）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>放弃EventBus和Redis Client的追踪，下次一定.jpg&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sidecar里面记得排除不必要的plugin：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rm /skywalking/agent/plugins/apm-vertx-core-* /skywalking/agent/plugins/resteasy-server-3.x*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol></description></item><item><title>关于Quarkus的碎碎念</title><link>https://leibnizhu.github.io/p/%E5%85%B3%E4%BA%8EQuarkus%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</link><pubDate>Sun, 15 May 2022 16:03:10 +0800</pubDate><guid>https://leibnizhu.github.io/p/%E5%85%B3%E4%BA%8EQuarkus%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</guid><description>&lt;img src="https://leibnizhu.github.io/p/%E5%85%B3%E4%BA%8EQuarkus%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/thumbnail.jpg" alt="Featured image of post 关于Quarkus的碎碎念" />&lt;p>最近把一个老项目迁到了Quarkus，想谈谈一些感想和想-法。&lt;/p>
&lt;h2 id="why-quarkus">Why Quarkus???&lt;/h2>
&lt;p>答案很简单，for 云原生。在 &lt;a class="link" href="https://quarkus.io/" target="_blank" rel="noopener"
>官网&lt;/a> 也可以看到Quarkus的宣传点也是围绕云原生进行的。&lt;br>
云原生的实现大概有这些要点：&lt;/p>
&lt;ol>
&lt;li>应用/架构设计遵循 &lt;a class="link" href="https://12factor.net/" target="_blank" rel="noopener"
>12-Factor&lt;/a>&lt;/li>
&lt;li>服务容器化，最好框架层面就有支持&lt;/li>
&lt;li>启动速度快，资源占用少，便于伸缩。这里又包括镜像大小、layer设计、应用本身启动速度等因素。&lt;/li>
&lt;li>配合GitOps持续集成、持续交付&lt;/li>
&lt;/ol>
&lt;p>而Quarkus很好解决了这些问题。反观Spring，在启动速度、资源占用这块实在不尽人意，对k8s的支持也是很落后，对graalvm native- image也是起步落后。&lt;/p>
&lt;h2 id="用不用native">用不用Native??&lt;/h2>
&lt;p>谈Quarkus绕不开native（native可执行文件的构建）。没办法，官方先来的，首页就是大大的native/jvm性能对比。&lt;br>
native实测是真的快（不到0.1s），内存占用也确实小（启动几十MB，跑一段时间稳定大概300MB附近，不过不同压力的不同类型服务也不能说明什么）。但有什么缺点？&lt;/p>
&lt;ol>
&lt;li>&lt;strong>编译速度慢&lt;/strong> ：一个比较简单的web服务，在我们CICD的机器上编译大概需要4min，如果是容器内multistage编译则时间更长，但直接编译对环境又有要求，所以还是最好有更强大的编译机器。&lt;/li>
&lt;li>&lt;strong>编译产物体积大&lt;/strong> ：我们编译出来的二进制文件大约130-150MB，&lt;code>upx&lt;/code> 压缩后40MB以内；单看最后的docker镜像，如果用最小的基础镜像，大约整个镜像可以做到100MB以内，是挺小的；但是每次构建变更的layer，都是整个二进制文件的变更，也就是没次编译多了一个40MB的layer出来，体积相当可观。同样的服务，如果打jar，真正变更的只有不到1MB，pod拉镜像的速度会更快，对docker仓库的压力也更小。&lt;/li>
&lt;li>&lt;strong>开发多了不少限制&lt;/strong> ：你要注意新引入的依赖是不是支持native的；所以可能需要json序列化反序列化的类记得加上 &lt;code>@RegisterForReflection&lt;/code> 注解；如果是外部依赖的实体类，要编写一个什么json文件声明要处理…………本文不是Quarkus教程，就不详细展开了，总之，如果要native，最好整个服务都只用quarkus生态里面的依赖，否则你不知道什么时候就编译不了了。虽然quarkus的生态已经比较完善，但总有没cover到的地方，比如hadoop生态的sdk。&lt;/li>
&lt;/ol>
&lt;p>没错，我们quarkus native上了生产一两个月，运行良好，充分体现了native的优越性；但是，现在要加入hadoop这些，没办法，只能放弃，要么自己实现一整套hdfs client之类的，成本很高。&lt;/p>
&lt;h2 id="响应式要上吗">响应式要上吗?&lt;/h2>
&lt;p>官网说：&lt;/p>
&lt;blockquote>
&lt;p>Unifies imperative and reactive
Combine both the familiar imperative code and the reactive style when developing applications.&lt;/p>
&lt;/blockquote>
&lt;p>真的有那么Unify吗？未必哦。&lt;br>
这里说的 &lt;code>Unifies imperative and reactive&lt;/code> 是指：&lt;/p>
&lt;ul>
&lt;li>Quarkus core基于Vert.X实现，是响应式的，这也是它能unify命令式和响应式的关键原因，也是各个扩展能自行选择命令式实现和响应式实现的原因&lt;/li>
&lt;li>Quarkus在Vert.X基础上做了一个路由层来兼容两种实现，像HTTP请求这种直接通过路由层、如果是响应式代码，直接在I/O线程上执行；命令式代码则丢到Worker线程执行（就要做上下文切换了）；至于Quarkus怎么知道是什么实现，就看方法注解以及签名了，具体不展开&lt;/li>
&lt;li>也就是说，至少在http接口这一层面，开发者可以选择用命令式还是响应式编程实现，另外定时任务、Eventbus之类也是支持的&lt;/li>
&lt;li>但到了ORM层只能有一个选择，是的， &lt;code>Hibernate&lt;/code> 和 &lt;code>Hibernate-reactive&lt;/code> 显然不能共存。&lt;/li>
&lt;/ul>
&lt;p>如果选了 &lt;code>Hibernate-reactive&lt;/code> 那么意味你的dao都是返回Uni或Multi，这会一直传递出去（除非await结果）。&lt;br>
另外，像 &lt;code>resteasy&lt;/code> 用了reative的话，filter这些在I/O线程运行，不能阻塞，如果里面用到redis client之类也要改Reactive RedisClient。&lt;br>
总而言之，选了Reactive，多少是有 &lt;strong>传递性&lt;/strong> 的，很多地方要跟着改。&lt;br>
在我们的项目里，也开了个分支彻底改了Reactive，发现在一些地方支持还不是很好，比如 ：&lt;/p>
&lt;ul>
&lt;li>&lt;code>@Scheduled&lt;/code> 方法里面开Panache的多表事务会报错&lt;/li>
&lt;li>EventBus的 &lt;code>@ConsumeEvent&lt;/code> 注释的方法，同上&lt;/li>
&lt;li>&lt;code>Hibernate-reactive&lt;/code> 不支持 OneToMany ManyToOne 等的懒加载，必须在HQL用 &lt;code>join fetch&lt;/code> 声明拉外表（就不是lazy了）&lt;/li>
&lt;li>………………&lt;/li>
&lt;/ul>
&lt;p>最后，基于以下考虑，放弃了reactive：&lt;/p>
&lt;ol>
&lt;li>老代码迁移，不可能dao全部改reactive，况且dao层还会往外传递reactive&lt;/li>
&lt;li>quarkus reactive 本身限制，比如上面列的一些点&lt;/li>
&lt;li>团队接受、理解Reactive的成本&lt;/li>
&lt;li>&lt;a class="link" href="https://openjdk.java.net/jeps/425" target="_blank" rel="noopener"
>virtual thread&lt;/a> 已经进入 jdk19 preview了，到下个LTS，jdk21，quarkus应该已经跟进支持，到时切过去就是。&lt;/li>
&lt;/ol>
&lt;p>从长远来看，趋势应该是开发者只要写同步代码，不用管实际执行，通过虚拟线程压榨线程性能，大部分需求不需要在代码层面通过类似reactive这样的pattern提高性能。&lt;br>
当然不是说有了Loom、reactive就没用了，只是说在压榨线程性能这一点上，可以交给loom；而我们用reactive也不只是为了性能，具体就不展开了，可以看看 &lt;a class="link" href="https://www.reactivemanifesto.org/" target="_blank" rel="noopener"
>The Reactive Manifesto&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>有一说一，Quarkus 的 mutiny对比RxJava之类，好用不是一点两点，接口设计相当优秀，值得学习。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;h2 id="其他">其他&lt;/h2>
&lt;h3 id="openapi">OpenAPI&lt;/h3>
&lt;p>回顾下使用OpenAPI的目的：&lt;/p>
&lt;ol>
&lt;li>接口标准&lt;/li>
&lt;li>提供给其他业务方/前端访问文档&lt;/li>
&lt;li>提供给其他业务方自己按需生成SDK使用&lt;/li>
&lt;/ol>
&lt;p>第1点是OpenAPI本身的特性，第2点Quarkus可以集成。&lt;br>
Quarkus对OpenAPI的支持可以见 &lt;a class="link" href="https://quarkus.io/guides/openapi-swaggerui" target="_blank" rel="noopener"
>官网Guides&lt;/a> ，说几个点：&lt;/p>
&lt;ol>
&lt;li>支持按代码生成OpenAPI定义&lt;/li>
&lt;li>支持按代码生成Swagger-UI界面（后者默认是dev模式才有，可以通过 &lt;code>quarkus.swagger-ui.always-include=true&lt;/code> 开启非dev模式下可用）&lt;/li>
&lt;li>支持放一个自己写的OpenAPI定义文件，作为上面1、2点生成的一部分；但，Quarkus要求openapi定义文件必须放在固定路径下，如&lt;code>resources/META-INF/openapi.yml&lt;/code>
等几个指定路径，具体参见 &lt;a class="link" href="https://quarkus.io/guides/openapi-swaggerui#open-document-paths" target="_blank" rel="noopener"
>Using OpenAPI And Swagger UI&lt;/a> 。&lt;/li>
&lt;/ol>
&lt;p>第3点会带来一些不便，比如，OpenAPI spec文件在另一个项目，deploy到maven仓库，Quarkus的项目去依赖的时候，就要求它按这个目录来，如果OpenAPI spec是外部的项目，就不好控制了。&lt;/p>
&lt;h3 id="restclient">RestClient&lt;/h3>
&lt;p>Quarkus的 &lt;a class="link" href="https://quarkus.io/guides/rest-client-reactive" target="_blank" rel="noopener"
>RestClient&lt;/a> 基本功能是完备的，配合 &lt;code>quarkus-smallrye-fault-tolerance&lt;/code> 可以做一些重试啊、Fallback啊、熔断啊之类的操作。&lt;br>
但有两个点要吐槽下：&lt;/p>
&lt;ol>
&lt;li>RestClient是可以通过 &lt;code>@RegisterClientHeaders&lt;/code> 注册一个请求header的处理器的；但这个处理器的生命周期是restclient自己管的，给一个输入的header，你可以往里加header之类，实际上能操作的空间的很小，一般就是只能加一些固定的header。所以很多时候只能在接口方法加 &lt;code>@HeaderParam&lt;/code> 的参数，如果又有一些固定的header处理逻辑，要么就写一层Facade，要么就在接口里做个default方法处理下。&lt;/li>
&lt;li>接口的异常处理定义比较弱，基本只能通过Interceptor、或者异常捕获；比如想根据响应http status code有不同处理，获取响应header这种，就比较麻烦。&lt;/li>
&lt;/ol>
&lt;h3 id="multipart">Multipart&lt;/h3>
&lt;p>有一点比较坑的，&lt;code>@MultipartForm&lt;/code> 注解有俩：&lt;/p>
&lt;ul>
&lt;li>org.jboss.resteasy.annotations.providers.multipart.MultipartForm&lt;/li>
&lt;li>org.jboss.resteasy.reactive.MultipartForm&lt;/li>
&lt;/ul>
&lt;p>还都是resteasy下的，注意哈，用第一个才行的，resteasy-multipart-provider 里面的。&lt;/p>
&lt;h3 id="redisclient">RedisClient&lt;/h3>
&lt;p>好几个方法，如 &lt;code>io.quarkus.redis.client.RedisClient#del&lt;/code> ，没用变长参数，用的是List接收参数。 算是有点不方便吧。&lt;/p></description></item></channel></rss>