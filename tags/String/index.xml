<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>String on Heaven's Door</title><link>https://leibnizhu.github.io/tags/String/</link><description>Recent content in String on Heaven's Door</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 09 Jul 2017 20:54:16 +0800</lastBuildDate><atom:link href="https://leibnizhu.github.io/tags/String/index.xml" rel="self" type="application/rss+xml"/><item><title>String源码阅读笔记（JDK8）</title><link>https://leibnizhu.github.io/p/String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/</link><pubDate>Sun, 09 Jul 2017 20:54:16 +0800</pubDate><guid>https://leibnizhu.github.io/p/String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/</guid><description>&lt;img src="https://leibnizhu.github.io/p/String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0JDK8/cup.png" alt="Featured image of post String源码阅读笔记（JDK8）" />&lt;h1 id="string源码阅读笔记">String源码阅读笔记&lt;/h1>
&lt;h2 id="成员变量">成员变量&lt;/h2>
&lt;p>value，存放String数据，不可变。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#815ba4">final&lt;/span> &lt;span style="color:#fec418">char&lt;/span> value&lt;span style="color:#5bc4bf">[];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hash，存放String的哈希值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">private&lt;/span> &lt;span style="color:#fec418">int&lt;/span> hash&lt;span style="color:#5bc4bf">;&lt;/span> &lt;span style="color:#776e71">// Default to 0
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="构造器部分">构造器部分&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>String original&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将参数的value和hash复制给当前对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> value&lt;span style="color:#5bc4bf">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>Arrays.copyOf()&lt;/code>复制到value属性中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> value&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> count&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先判断offset和count与value的长度对比是否可用，然后调用&lt;code>Arrays.copyOfRange()&lt;/code>复制到value属性中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> codePoints&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> count&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>类似上面，判断完之后，再遍历codePoints排除非法int，最后遍历codePoints强转char[]，赋值给value属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> length&lt;span style="color:#5bc4bf">,&lt;/span> String charsetName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查参数没有越界后，调用&lt;code>StringCoding.decode()&lt;/code>生成char[]赋值给value属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> length&lt;span style="color:#5bc4bf">,&lt;/span> Charset charset&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>类似上面，只是代表编码的参数改了类型。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> String charsetName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> Charset charset&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> length&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span> bytes&lt;span style="color:#5bc4bf">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别调用上面两个构造方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>StringBuffer buffer&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>StringBuilder builder&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>Arrays.copyOf()&lt;/code>利用参数的value和length生成char[]赋值给value属性。两者区别在于前者多了synchronized修饰。&lt;br>
而关于&lt;code>StringCoding.decode()&lt;/code>，从源码可以看出来，默认的情况下会调用Charset.defaultCharset()获取默认编码，默认情况下获取到&lt;code>UTF-8&lt;/code>编码，如果获取失败或者获取到的并不支持的话则使用&lt;code>ISO-8859-1&lt;/code>编码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/* StringCoding类 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">static&lt;/span> &lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">decode&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">byte&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> ba&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> off&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> len&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String csn &lt;span style="color:#5bc4bf">=&lt;/span> Charset&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">defaultCharset&lt;/span>&lt;span style="color:#5bc4bf">().&lt;/span>&lt;span style="color:#06b6ef">name&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">try&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// use charset name decode() variant which provides caching.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">return&lt;/span> decode&lt;span style="color:#5bc4bf">(&lt;/span>csn&lt;span style="color:#5bc4bf">,&lt;/span> ba&lt;span style="color:#5bc4bf">,&lt;/span> off&lt;span style="color:#5bc4bf">,&lt;/span> len&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span> &lt;span style="color:#815ba4">catch&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>UnsupportedEncodingException x&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> warnUnsupportedCharset&lt;span style="color:#5bc4bf">(&lt;/span>csn&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">try&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> decode&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;ISO-8859-1&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">,&lt;/span> ba&lt;span style="color:#5bc4bf">,&lt;/span> off&lt;span style="color:#5bc4bf">,&lt;/span> len&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span> &lt;span style="color:#815ba4">catch&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>UnsupportedEncodingException x&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// If this code is hit during VM initialization, MessageUtils is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">// the only way we will be able to get any kind of error message.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> MessageUtils&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">err&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;ISO-8859-1 charset not available: &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">+&lt;/span> x&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">toString&lt;/span>&lt;span style="color:#5bc4bf">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// If we can not find ISO-8859-1 (a required encoding) then things
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#776e71">// are seriously wrong with the installation.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> System&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">exit&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#f99b15">1&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">/* Charset类 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">static&lt;/span> Charset &lt;span style="color:#06b6ef">defaultCharset&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>defaultCharset &lt;span style="color:#5bc4bf">==&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">synchronized&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>Charset&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">class&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String csn &lt;span style="color:#5bc4bf">=&lt;/span> AccessController&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">doPrivileged&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">new&lt;/span> GetPropertyAction&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;file.encoding&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Charset cs &lt;span style="color:#5bc4bf">=&lt;/span> lookup&lt;span style="color:#5bc4bf">(&lt;/span>csn&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">if&lt;/span> &lt;span style="color:#5bc4bf">(&lt;/span>cs &lt;span style="color:#5bc4bf">!=&lt;/span> &lt;span style="color:#815ba4">null&lt;/span>&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultCharset &lt;span style="color:#5bc4bf">=&lt;/span> cs&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultCharset &lt;span style="color:#5bc4bf">=&lt;/span> forName&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#48b685">&amp;#34;UTF-8&amp;#34;&lt;/span>&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#815ba4">return&lt;/span> defaultCharset&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有值得注意的时，String还提供了一个保护类型的构造方法&lt;code>String(char[] value, boolean share)&lt;/code>，与&lt;code>String(char[] value)&lt;/code>区别在于多了一个没用的参数，以便重载构造方法，而且实现时直接将参数的数组赋值给当前String对象的value属性，而不是复制数组，也就是说这个方法构造出来的String和参数传过来的char[]共享同一个数组，并不安全，这样的设计是出于性能和节约内存的考虑，因此这个方法是包私有的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> value&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> share&lt;span style="color:#5bc4bf">)&lt;/span> &lt;span style="color:#5bc4bf">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#776e71">// assert share : &amp;#34;unshared not supported&amp;#34;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#776e71">&lt;/span> &lt;span style="color:#815ba4">this&lt;/span>&lt;span style="color:#5bc4bf">.&lt;/span>&lt;span style="color:#06b6ef">value&lt;/span> &lt;span style="color:#5bc4bf">=&lt;/span> value&lt;span style="color:#5bc4bf">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5bc4bf">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="其他方法">其他方法&lt;/h2>
&lt;h3 id="静态工厂方法">静态工厂方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object obj&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Object的toString()方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> data&lt;span style="color:#5bc4bf">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">copyValueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> data&lt;span style="color:#5bc4bf">[]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用String(char value[])构造器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> data&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> count&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">copyValueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> data&lt;span style="color:#5bc4bf">[],&lt;/span> &lt;span style="color:#fec418">int&lt;/span> offset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> count&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用String(char value[], int offset, int count)构造器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">boolean&lt;/span> b&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回&amp;quot;true&amp;quot;或&amp;quot;false&amp;quot;。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> c&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用String(char[] value, true)构造器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> i&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">long&lt;/span> l&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">float&lt;/span> f&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">valueOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">double&lt;/span> d&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用参数对应包装类的toString()方法。&lt;/p>
&lt;h3 id="intern方法">intern()方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#815ba4">public&lt;/span> &lt;span style="color:#815ba4">native&lt;/span> String &lt;span style="color:#06b6ef">intern&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法返回一个字符串对象的内部化引用。 众所周知：String类维护一个初始为空的字符串的对象池，当intern方法被调用时，如果对象池中已经包含这一个相等的字符串对象则返回对象池中的实例，否则添加字符串到对象池并返回该字符串的引用。&lt;/p>
&lt;h3 id="对的重载">对“+”的重载&lt;/h3>
&lt;p>String对“+”的支持其实就是使用了StringBuilder以及他的append()、toString()le两个方法。&lt;/p>
&lt;h3 id="常规方法">常规方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">isEmpty&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>判断length是否为0。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">char&lt;/span> &lt;span style="color:#06b6ef">charAt&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>判断越界，然后直接从value数组取值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">codePointAt&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">codePointBefore&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">codePointCount&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> beginIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> endIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">offsetByCodePoints&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> index&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> codePointOffset&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>判断越界然后调用Character对应静态方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">byte&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">getBytes&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String charsetName&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">byte&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">getBytes&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Charset charset&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">byte&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">getBytes&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用StringCoding.encode()编码返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">substring&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> beginIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">substring&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> beginIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> endIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CharSequence &lt;span style="color:#06b6ef">subSequence&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> beginIndex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> endIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用String的构造方法&lt;code>String(char value[], int offset, int count)&lt;/code>，将会将原来的char[]中的值逐一复制到新的String中，两个数组并不是共享的，虽然这样做损失一些性能，但是有效地避免了内存泄露。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">concat&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先将原来数据用&lt;code>Arrays.copyOf()&lt;/code>复制到一个char数组中，然后调用&lt;code>getChars()&lt;/code>将str的值复制到char数组后面，最后调用共享char[]的构造方法将char数组构造成新的String对象并返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">matches&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Pattern.matches()方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">contains&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>CharSequence s&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用indexOf()进行判断，只要返回索引大于-1即包含。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">split&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> limit&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">split&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>后者调用前者；如果regex长度为1而且不包含&lt;code>&amp;quot;.$|()[{^?*+\\&amp;quot;&lt;/code>，或者regex长度为2而且以&lt;code>&amp;quot;\\&amp;quot;&lt;/code>开头且第二个字符非数字字母（总而言之分割的正则其实只有一个字符），则创建一个List，遍历value，读取匹配到regex的时候，切取分隔符前面的子字符串，放入List中，最后一段也放入List，最后根据limit创建一个子List转换为String[]并返回；否则调用&lt;code>Pattern.compile(regex).split()&lt;/code>进行计算并返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">join&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>CharSequence delimiter&lt;span style="color:#5bc4bf">,&lt;/span> CharSequence&lt;span style="color:#5bc4bf">...&lt;/span> elements&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">join&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>CharSequence delimiter&lt;span style="color:#5bc4bf">,&lt;/span> Iterable&lt;span style="color:#5bc4bf">&amp;lt;?&lt;/span> &lt;span style="color:#815ba4">extends&lt;/span> CharSequence&lt;span style="color:#5bc4bf">&amp;gt;&lt;/span> elements&lt;span style="color:#5bc4bf">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用StringJoiner的add()和toString()方法进行拼接。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">toLowerCase&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Locale locale&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">toLowerCase&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">toUpperCase&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Locale locale&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">toUpperCase&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>涉及到多语言的实现，实现起来比较复杂，没仔细看。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">trim&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别从头和尾开始遍历找到首次不为空字符的位置，取子字符串返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> &lt;span style="color:#06b6ef">toCharArray&lt;/span>&lt;span style="color:#5bc4bf">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建一个同样长度的char数组，调用&lt;code>System.arraycopy()&lt;/code>复制并返回，避免安全性问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">format&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String format&lt;span style="color:#5bc4bf">,&lt;/span> Object&lt;span style="color:#5bc4bf">...&lt;/span> args&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">format&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Locale l&lt;span style="color:#5bc4bf">,&lt;/span> String format&lt;span style="color:#5bc4bf">,&lt;/span> Object&lt;span style="color:#5bc4bf">...&lt;/span> args&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Formatter的&lt;code>format()&lt;/code>方法进行计算并返回。&lt;/p>
&lt;h3 id="替代方法">替代方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">replace&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span> oldChar&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">char&lt;/span> newChar&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果新旧字符一样则直接返回this好了，否则先遍历，找到第一次出现oldChar的下标，如果没找到也是返回this，找到则将该下标之前的值循环复制到新数组，此下标之后的值复制到新数组的时候先判断是否oldChar，是的话复制newChar到新数组；最后用新数组构造一个String并返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">replaceFirst&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">,&lt;/span> String replacement&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Pattern.matcher()找到匹配之后，再调用Matcher.replaceFirst()来替换首次出现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">replaceAll&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String regex&lt;span style="color:#5bc4bf">,&lt;/span> String replacement&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用Pattern.matcher()找到匹配之后，再调用Matcher.replaceAll()来替换全部。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#06b6ef">replace&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>CharSequence target&lt;span style="color:#5bc4bf">,&lt;/span> CharSequence replacement&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样调用Pattern.matcher().replaceAll()，支持单个字符。&lt;/p>
&lt;h3 id="比较方法">比较方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">equals&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>Object anObject&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先判断是否this，再判断是否String对象，再判断长度是否相等，最后逐个char进行对比。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">contentEquals&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>StringBuffer sb&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>contentEquals(CharSequence cs)&lt;/code>，该方法判断如果是StringBuffer则加同步去执行&lt;code>nonSyncContentEquals(AbstractStringBuilder sb)&lt;/code>，否则（StringBuilder的情况）不加同步直接执行。 而&lt;code>nonSyncContentEquals(AbstractStringBuilder sb)&lt;/code>中具体的比较流程与equals基本一致。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">equalsIgnoreCase&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String anotherString&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先后判断是否this、是否null、长度是否相同，然后调用&lt;code>boolean regionMatches()&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">regionMatches&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">boolean&lt;/span> ignoreCase&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toffset&lt;span style="color:#5bc4bf">,&lt;/span> String other&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> ooffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> len&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比较this和other是否相等，先判断越界，再逐个字符比较，相同则继续，不同则根据ignoreCase参数，如果true则先将比较双方转成大写进行相等判断，还不相等则转成小写（针对格鲁吉亚语）进行判断。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">startsWith&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String prefix&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> toffset&lt;span style="color:#5bc4bf">),&lt;/span> &lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">startsWith&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String prefix&lt;span style="color:#5bc4bf">)&lt;/span>&lt;span style="color:#ef6155">```&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ef6155">后者调用前者，从指定偏移量开始，逐个字符进行判断是否相等，判断次数为&lt;/span>prefix&lt;span style="color:#ef6155">的长度。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ef6155">```&lt;/span>java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">boolean&lt;/span> &lt;span style="color:#06b6ef">endsWith&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String suffix&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用&lt;code>startsWith(suffix, value.length - suffix.value.length)&lt;/code>，判断this的后面N（suffix的长度）个字符是否与suffix相等。&lt;/p>
&lt;h3 id="哈希方法">哈希方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">hashCode&lt;/span>&lt;span style="color:#5bc4bf">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>hash属性初始化为0，如果调用hashCode()的时候发现hash为0则开始计算哈希值（懒加载）；由于String不可变，则hash计算一次即可。哈希算法核心为&lt;code>h = 31 * h + val[i];&lt;/code>，遍历所有字符，循环地加上乘以31的哈希值作为新的哈希值，相当于&lt;code>val[0]*31^(n-1) + val[1]*31^(n-2) + ... + val[n-1]&lt;/code>；而选用31，可能时出于&lt;code>i*31== (i&amp;lt;&amp;lt;5)-1&lt;/code>的考虑。&lt;/p>
&lt;h3 id="查找方法">查找方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前者调用后者（fromIndex=0），先判断越界，然后有两种情况就是ch对应单字节和双字节，单字节则直接从fromIndex开始遍历对比查找，双字节则调用&lt;code>int indexOfSupplementary(int ch, int fromIndex)&lt;/code>遍历查找的时候同时判断两个字节。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOfSupplementary&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">int&lt;/span> ch&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与indexOf()系列类似，只是遍历查找的起点和方向不同。&lt;br>
 &lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> source&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceCount&lt;span style="color:#5bc4bf">,&lt;/span> String target&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">indexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> source&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceCount&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> target&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> targetOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> targetCount&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前三者调用最后一个方法。处理完越界和特殊情况后，开始遍历，遍历过程中每次先找到this中出现target的第一个字符（减少判断），找到后开始从当前下标开始，this的值与target的值逐个比较，判断到不相等的值或者到target的结尾则退出判断，然后如果退出判断时的下标等于开始判断下标+target长度，那么就是找到了，返回开始判断的下标，否则继续外面的循环。并没有用KMP算法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>String str&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> source&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceCount&lt;span style="color:#5bc4bf">,&lt;/span> String target&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fec418">int&lt;/span> &lt;span style="color:#06b6ef">lastIndexOf&lt;/span>&lt;span style="color:#5bc4bf">(&lt;/span>&lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> source&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> sourceCount&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">char&lt;/span>&lt;span style="color:#5bc4bf">[]&lt;/span> target&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> targetOffset&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> targetCount&lt;span style="color:#5bc4bf">,&lt;/span> &lt;span style="color:#fec418">int&lt;/span> fromIndex&lt;span style="color:#5bc4bf">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与indexOf()系列类似，只是查找的方向以及起始位置不一样了。&lt;/p></description></item></channel></rss>